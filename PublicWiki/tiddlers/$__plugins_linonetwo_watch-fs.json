{
    "tiddlers": {
        "$:/plugins/linonetwo/watch-fs/3rds.js": {
            "title": "$:/plugins/linonetwo/watch-fs/3rds.js",
            "text": "'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar require$$0$3 = require('events');\n\nvar fs = require('fs');\n\nvar sysPath = require('path');\n\nvar require$$0$1 = require('util');\n\nvar require$$0$2 = require('stream');\n\nvar require$$1 = require('os');\n\nvar require$$1$1 = {};\n\nfunction _interopDefaultLegacy(e) {\n  return e && typeof e === 'object' && 'default' in e ? e : {\n    'default': e\n  };\n}\n\nvar require$$0__default$2 = /*#__PURE__*/_interopDefaultLegacy(require$$0$3);\n\nvar fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);\n\nvar sysPath__default = /*#__PURE__*/_interopDefaultLegacy(sysPath);\n\nvar require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0$1);\n\nvar require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$2);\n\nvar require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1);\n\nvar require$$1__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$1$1);\n\nfunction createCommonjsModule(fn, basedir, module) {\n  return module = {\n    path: basedir,\n    exports: {},\n    require: function (path, base) {\n      return commonjsRequire(path, base === undefined || base === null ? module.path : base);\n    }\n  }, fn(module, module.exports), module.exports;\n}\n\nfunction commonjsRequire() {\n  throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');\n}\n\nconst WIN_SLASH = '\\\\\\\\/';\nconst WIN_NO_SLASH = `[^${WIN_SLASH}]`;\n/**\n * Posix glob regex\n */\n\nconst DOT_LITERAL = '\\\\.';\nconst PLUS_LITERAL = '\\\\+';\nconst QMARK_LITERAL = '\\\\?';\nconst SLASH_LITERAL = '\\\\/';\nconst ONE_CHAR = '(?=.)';\nconst QMARK = '[^/]';\nconst END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;\nconst START_ANCHOR = `(?:^|${SLASH_LITERAL})`;\nconst DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;\nconst NO_DOT = `(?!${DOT_LITERAL})`;\nconst NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;\nconst NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;\nconst NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;\nconst QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;\nconst STAR = `${QMARK}*?`;\nconst POSIX_CHARS = {\n  DOT_LITERAL,\n  PLUS_LITERAL,\n  QMARK_LITERAL,\n  SLASH_LITERAL,\n  ONE_CHAR,\n  QMARK,\n  END_ANCHOR,\n  DOTS_SLASH,\n  NO_DOT,\n  NO_DOTS,\n  NO_DOT_SLASH,\n  NO_DOTS_SLASH,\n  QMARK_NO_DOT,\n  STAR,\n  START_ANCHOR\n};\n/**\n * Windows glob regex\n */\n\nconst WINDOWS_CHARS = { ...POSIX_CHARS,\n  SLASH_LITERAL: `[${WIN_SLASH}]`,\n  QMARK: WIN_NO_SLASH,\n  STAR: `${WIN_NO_SLASH}*?`,\n  DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,\n  NO_DOT: `(?!${DOT_LITERAL})`,\n  NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,\n  NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,\n  QMARK_NO_DOT: `[^.${WIN_SLASH}]`,\n  START_ANCHOR: `(?:^|[${WIN_SLASH}])`,\n  END_ANCHOR: `(?:[${WIN_SLASH}]|$)`\n};\n/**\n * POSIX Bracket Regex\n */\n\nconst POSIX_REGEX_SOURCE = {\n  alnum: 'a-zA-Z0-9',\n  alpha: 'a-zA-Z',\n  ascii: '\\\\x00-\\\\x7F',\n  blank: ' \\\\t',\n  cntrl: '\\\\x00-\\\\x1F\\\\x7F',\n  digit: '0-9',\n  graph: '\\\\x21-\\\\x7E',\n  lower: 'a-z',\n  print: '\\\\x20-\\\\x7E ',\n  punct: '\\\\-!\"#$%&\\'()\\\\*+,./:;<=>?@[\\\\]^_`{|}~',\n  space: ' \\\\t\\\\r\\\\n\\\\v\\\\f',\n  upper: 'A-Z',\n  word: 'A-Za-z0-9_',\n  xdigit: 'A-Fa-f0-9'\n};\nvar constants = {\n  MAX_LENGTH: 1024 * 64,\n  POSIX_REGEX_SOURCE,\n  // regular expressions\n  REGEX_BACKSLASH: /\\\\(?![*+?^${}(|)[\\]])/g,\n  REGEX_NON_SPECIAL_CHARS: /^[^@![\\].,$*+?^{}()|\\\\/]+/,\n  REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\\]]/,\n  REGEX_SPECIAL_CHARS_BACKREF: /(\\\\?)((\\W)(\\3*))/g,\n  REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\\]])/g,\n  REGEX_REMOVE_BACKSLASH: /(?:\\[.*?[^\\\\]\\]|\\\\(?=.))/g,\n  // Replace globs with equivalent patterns to reduce parsing time.\n  REPLACEMENTS: {\n    '***': '*',\n    '**/**': '**',\n    '**/**/**': '**'\n  },\n  // Digits\n  CHAR_0: 48,\n\n  /* 0 */\n  CHAR_9: 57,\n\n  /* 9 */\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 65,\n\n  /* A */\n  CHAR_LOWERCASE_A: 97,\n\n  /* a */\n  CHAR_UPPERCASE_Z: 90,\n\n  /* Z */\n  CHAR_LOWERCASE_Z: 122,\n\n  /* z */\n  CHAR_LEFT_PARENTHESES: 40,\n\n  /* ( */\n  CHAR_RIGHT_PARENTHESES: 41,\n\n  /* ) */\n  CHAR_ASTERISK: 42,\n\n  /* * */\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: 38,\n\n  /* & */\n  CHAR_AT: 64,\n\n  /* @ */\n  CHAR_BACKWARD_SLASH: 92,\n\n  /* \\ */\n  CHAR_CARRIAGE_RETURN: 13,\n\n  /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: 94,\n\n  /* ^ */\n  CHAR_COLON: 58,\n\n  /* : */\n  CHAR_COMMA: 44,\n\n  /* , */\n  CHAR_DOT: 46,\n\n  /* . */\n  CHAR_DOUBLE_QUOTE: 34,\n\n  /* \" */\n  CHAR_EQUAL: 61,\n\n  /* = */\n  CHAR_EXCLAMATION_MARK: 33,\n\n  /* ! */\n  CHAR_FORM_FEED: 12,\n\n  /* \\f */\n  CHAR_FORWARD_SLASH: 47,\n\n  /* / */\n  CHAR_GRAVE_ACCENT: 96,\n\n  /* ` */\n  CHAR_HASH: 35,\n\n  /* # */\n  CHAR_HYPHEN_MINUS: 45,\n\n  /* - */\n  CHAR_LEFT_ANGLE_BRACKET: 60,\n\n  /* < */\n  CHAR_LEFT_CURLY_BRACE: 123,\n\n  /* { */\n  CHAR_LEFT_SQUARE_BRACKET: 91,\n\n  /* [ */\n  CHAR_LINE_FEED: 10,\n\n  /* \\n */\n  CHAR_NO_BREAK_SPACE: 160,\n\n  /* \\u00A0 */\n  CHAR_PERCENT: 37,\n\n  /* % */\n  CHAR_PLUS: 43,\n\n  /* + */\n  CHAR_QUESTION_MARK: 63,\n\n  /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: 62,\n\n  /* > */\n  CHAR_RIGHT_CURLY_BRACE: 125,\n\n  /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: 93,\n\n  /* ] */\n  CHAR_SEMICOLON: 59,\n\n  /* ; */\n  CHAR_SINGLE_QUOTE: 39,\n\n  /* ' */\n  CHAR_SPACE: 32,\n\n  /*   */\n  CHAR_TAB: 9,\n\n  /* \\t */\n  CHAR_UNDERSCORE: 95,\n\n  /* _ */\n  CHAR_VERTICAL_LINE: 124,\n\n  /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,\n\n  /* \\uFEFF */\n  SEP: sysPath__default['default'].sep,\n\n  /**\n   * Create EXTGLOB_CHARS\n   */\n  extglobChars(chars) {\n    return {\n      '!': {\n        type: 'negate',\n        open: '(?:(?!(?:',\n        close: `))${chars.STAR})`\n      },\n      '?': {\n        type: 'qmark',\n        open: '(?:',\n        close: ')?'\n      },\n      '+': {\n        type: 'plus',\n        open: '(?:',\n        close: ')+'\n      },\n      '*': {\n        type: 'star',\n        open: '(?:',\n        close: ')*'\n      },\n      '@': {\n        type: 'at',\n        open: '(?:',\n        close: ')'\n      }\n    };\n  },\n\n  /**\n   * Create GLOB_CHARS\n   */\n  globChars(win32) {\n    return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;\n  }\n\n};\nvar utils = createCommonjsModule(function (module, exports) {\n  const win32 = process.platform === 'win32';\n  const {\n    REGEX_BACKSLASH,\n    REGEX_REMOVE_BACKSLASH,\n    REGEX_SPECIAL_CHARS,\n    REGEX_SPECIAL_CHARS_GLOBAL\n  } = constants;\n\n  exports.isObject = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\n  exports.hasRegexChars = str => REGEX_SPECIAL_CHARS.test(str);\n\n  exports.isRegexChar = str => str.length === 1 && exports.hasRegexChars(str);\n\n  exports.escapeRegex = str => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, '\\\\$1');\n\n  exports.toPosixSlashes = str => str.replace(REGEX_BACKSLASH, '/');\n\n  exports.removeBackslashes = str => {\n    return str.replace(REGEX_REMOVE_BACKSLASH, match => {\n      return match === '\\\\' ? '' : match;\n    });\n  };\n\n  exports.supportsLookbehinds = () => {\n    const segs = process.version.slice(1).split('.').map(Number);\n\n    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {\n      return true;\n    }\n\n    return false;\n  };\n\n  exports.isWindows = options => {\n    if (options && typeof options.windows === 'boolean') {\n      return options.windows;\n    }\n\n    return win32 === true || sysPath__default['default'].sep === '\\\\';\n  };\n\n  exports.escapeLast = (input, char, lastIdx) => {\n    const idx = input.lastIndexOf(char, lastIdx);\n    if (idx === -1) return input;\n    if (input[idx - 1] === '\\\\') return exports.escapeLast(input, char, idx - 1);\n    return `${input.slice(0, idx)}\\\\${input.slice(idx)}`;\n  };\n\n  exports.removePrefix = (input, state = {}) => {\n    let output = input;\n\n    if (output.startsWith('./')) {\n      output = output.slice(2);\n      state.prefix = './';\n    }\n\n    return output;\n  };\n\n  exports.wrapOutput = (input, state = {}, options = {}) => {\n    const prepend = options.contains ? '' : '^';\n    const append = options.contains ? '' : '$';\n    let output = `${prepend}(?:${input})${append}`;\n\n    if (state.negated === true) {\n      output = `(?:^(?!${output}).*$)`;\n    }\n\n    return output;\n  };\n});\nconst {\n  CHAR_ASTERISK,\n\n  /* * */\n  CHAR_AT,\n\n  /* @ */\n  CHAR_BACKWARD_SLASH,\n\n  /* \\ */\n  CHAR_COMMA,\n\n  /* , */\n  CHAR_DOT,\n\n  /* . */\n  CHAR_EXCLAMATION_MARK,\n\n  /* ! */\n  CHAR_FORWARD_SLASH,\n\n  /* / */\n  CHAR_LEFT_CURLY_BRACE,\n\n  /* { */\n  CHAR_LEFT_PARENTHESES,\n\n  /* ( */\n  CHAR_LEFT_SQUARE_BRACKET,\n\n  /* [ */\n  CHAR_PLUS,\n\n  /* + */\n  CHAR_QUESTION_MARK,\n\n  /* ? */\n  CHAR_RIGHT_CURLY_BRACE,\n\n  /* } */\n  CHAR_RIGHT_PARENTHESES,\n\n  /* ) */\n  CHAR_RIGHT_SQUARE_BRACKET\n  /* ] */\n\n} = constants;\n\nconst isPathSeparator = code => {\n  return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;\n};\n\nconst depth = token => {\n  if (token.isPrefix !== true) {\n    token.depth = token.isGlobstar ? Infinity : 1;\n  }\n};\n/**\n * Quickly scans a glob pattern and returns an object with a handful of\n * useful properties, like `isGlob`, `path` (the leading non-glob, if it exists),\n * `glob` (the actual pattern), and `negated` (true if the path starts with `!`).\n *\n * ```js\n * const pm = require('picomatch');\n * console.log(pm.scan('foo/bar/*.js'));\n * { isGlob: true, input: 'foo/bar/*.js', base: 'foo/bar', glob: '*.js' }\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {Object} Returns an object with tokens and regex source string.\n * @api public\n */\n\n\nconst scan = (input, options) => {\n  const opts = options || {};\n  const length = input.length - 1;\n  const scanToEnd = opts.parts === true || opts.scanToEnd === true;\n  const slashes = [];\n  const tokens = [];\n  const parts = [];\n  let str = input;\n  let index = -1;\n  let start = 0;\n  let lastIndex = 0;\n  let isBrace = false;\n  let isBracket = false;\n  let isGlob = false;\n  let isExtglob = false;\n  let isGlobstar = false;\n  let braceEscaped = false;\n  let backslashes = false;\n  let negated = false;\n  let finished = false;\n  let braces = 0;\n  let prev;\n  let code;\n  let token = {\n    value: '',\n    depth: 0,\n    isGlob: false\n  };\n\n  const eos = () => index >= length;\n\n  const peek = () => str.charCodeAt(index + 1);\n\n  const advance = () => {\n    prev = code;\n    return str.charCodeAt(++index);\n  };\n\n  while (index < length) {\n    code = advance();\n    let next;\n\n    if (code === CHAR_BACKWARD_SLASH) {\n      backslashes = token.backslashes = true;\n      code = advance();\n\n      if (code === CHAR_LEFT_CURLY_BRACE) {\n        braceEscaped = true;\n      }\n\n      continue;\n    }\n\n    if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {\n      braces++;\n\n      while (eos() !== true && (code = advance())) {\n        if (code === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (code === CHAR_LEFT_CURLY_BRACE) {\n          braces++;\n          continue;\n        }\n\n        if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (braceEscaped !== true && code === CHAR_COMMA) {\n          isBrace = token.isBrace = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n\n        if (code === CHAR_RIGHT_CURLY_BRACE) {\n          braces--;\n\n          if (braces === 0) {\n            braceEscaped = false;\n            isBrace = token.isBrace = true;\n            finished = true;\n            break;\n          }\n        }\n      }\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_FORWARD_SLASH) {\n      slashes.push(index);\n      tokens.push(token);\n      token = {\n        value: '',\n        depth: 0,\n        isGlob: false\n      };\n      if (finished === true) continue;\n\n      if (prev === CHAR_DOT && index === start + 1) {\n        start += 2;\n        continue;\n      }\n\n      lastIndex = index + 1;\n      continue;\n    }\n\n    if (opts.noext !== true) {\n      const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;\n\n      if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {\n        isGlob = token.isGlob = true;\n        isExtglob = token.isExtglob = true;\n        finished = true;\n\n        if (scanToEnd === true) {\n          while (eos() !== true && (code = advance())) {\n            if (code === CHAR_BACKWARD_SLASH) {\n              backslashes = token.backslashes = true;\n              code = advance();\n              continue;\n            }\n\n            if (code === CHAR_RIGHT_PARENTHESES) {\n              isGlob = token.isGlob = true;\n              finished = true;\n              break;\n            }\n          }\n\n          continue;\n        }\n\n        break;\n      }\n    }\n\n    if (code === CHAR_ASTERISK) {\n      if (prev === CHAR_ASTERISK) isGlobstar = token.isGlobstar = true;\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_QUESTION_MARK) {\n      isGlob = token.isGlob = true;\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n\n    if (code === CHAR_LEFT_SQUARE_BRACKET) {\n      while (eos() !== true && (next = advance())) {\n        if (next === CHAR_BACKWARD_SLASH) {\n          backslashes = token.backslashes = true;\n          advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET) {\n          isBracket = token.isBracket = true;\n          isGlob = token.isGlob = true;\n          finished = true;\n\n          if (scanToEnd === true) {\n            continue;\n          }\n\n          break;\n        }\n      }\n    }\n\n    if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {\n      negated = token.negated = true;\n      start++;\n      continue;\n    }\n\n    if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {\n      isGlob = token.isGlob = true;\n\n      if (scanToEnd === true) {\n        while (eos() !== true && (code = advance())) {\n          if (code === CHAR_LEFT_PARENTHESES) {\n            backslashes = token.backslashes = true;\n            code = advance();\n            continue;\n          }\n\n          if (code === CHAR_RIGHT_PARENTHESES) {\n            finished = true;\n            break;\n          }\n        }\n\n        continue;\n      }\n\n      break;\n    }\n\n    if (isGlob === true) {\n      finished = true;\n\n      if (scanToEnd === true) {\n        continue;\n      }\n\n      break;\n    }\n  }\n\n  if (opts.noext === true) {\n    isExtglob = false;\n    isGlob = false;\n  }\n\n  let base = str;\n  let prefix = '';\n  let glob = '';\n\n  if (start > 0) {\n    prefix = str.slice(0, start);\n    str = str.slice(start);\n    lastIndex -= start;\n  }\n\n  if (base && isGlob === true && lastIndex > 0) {\n    base = str.slice(0, lastIndex);\n    glob = str.slice(lastIndex);\n  } else if (isGlob === true) {\n    base = '';\n    glob = str;\n  } else {\n    base = str;\n  }\n\n  if (base && base !== '' && base !== '/' && base !== str) {\n    if (isPathSeparator(base.charCodeAt(base.length - 1))) {\n      base = base.slice(0, -1);\n    }\n  }\n\n  if (opts.unescape === true) {\n    if (glob) glob = utils.removeBackslashes(glob);\n\n    if (base && backslashes === true) {\n      base = utils.removeBackslashes(base);\n    }\n  }\n\n  const state = {\n    prefix,\n    input,\n    start,\n    base,\n    glob,\n    isBrace,\n    isBracket,\n    isGlob,\n    isExtglob,\n    isGlobstar,\n    negated\n  };\n\n  if (opts.tokens === true) {\n    state.maxDepth = 0;\n\n    if (!isPathSeparator(code)) {\n      tokens.push(token);\n    }\n\n    state.tokens = tokens;\n  }\n\n  if (opts.parts === true || opts.tokens === true) {\n    let prevIndex;\n\n    for (let idx = 0; idx < slashes.length; idx++) {\n      const n = prevIndex ? prevIndex + 1 : start;\n      const i = slashes[idx];\n      const value = input.slice(n, i);\n\n      if (opts.tokens) {\n        if (idx === 0 && start !== 0) {\n          tokens[idx].isPrefix = true;\n          tokens[idx].value = prefix;\n        } else {\n          tokens[idx].value = value;\n        }\n\n        depth(tokens[idx]);\n        state.maxDepth += tokens[idx].depth;\n      }\n\n      if (idx !== 0 || value !== '') {\n        parts.push(value);\n      }\n\n      prevIndex = i;\n    }\n\n    if (prevIndex && prevIndex + 1 < input.length) {\n      const value = input.slice(prevIndex + 1);\n      parts.push(value);\n\n      if (opts.tokens) {\n        tokens[tokens.length - 1].value = value;\n        depth(tokens[tokens.length - 1]);\n        state.maxDepth += tokens[tokens.length - 1].depth;\n      }\n    }\n\n    state.slashes = slashes;\n    state.parts = parts;\n  }\n\n  return state;\n};\n\nvar scan_1 = scan;\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH,\n  POSIX_REGEX_SOURCE: POSIX_REGEX_SOURCE$1,\n  REGEX_NON_SPECIAL_CHARS,\n  REGEX_SPECIAL_CHARS_BACKREF,\n  REPLACEMENTS\n} = constants;\n/**\n * Helpers\n */\n\nconst expandRange = (args, options) => {\n  if (typeof options.expandRange === 'function') {\n    return options.expandRange(...args, options);\n  }\n\n  args.sort();\n  const value = `[${args.join('-')}]`;\n\n  try {\n    /* eslint-disable-next-line no-new */\n    new RegExp(value);\n  } catch (ex) {\n    return args.map(v => utils.escapeRegex(v)).join('..');\n  }\n\n  return value;\n};\n/**\n * Create the message for a syntax error\n */\n\n\nconst syntaxError = (type, char) => {\n  return `Missing ${type}: \"${char}\" - use \"\\\\\\\\${char}\" to match literal characters`;\n};\n/**\n * Parse the given input string.\n * @param {String} input\n * @param {Object} options\n * @return {Object}\n */\n\n\nconst parse = (input, options) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const opts = { ...options\n  };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  let len = input.length;\n\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  const bos = {\n    type: 'bos',\n    value: '',\n    output: opts.prepend || ''\n  };\n  const tokens = [bos];\n  const capture = opts.capture ? '' : '?:';\n  const win32 = utils.isWindows(options); // create constants based on platform, for windows or posix\n\n  const PLATFORM_CHARS = constants.globChars(win32);\n  const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);\n  const {\n    DOT_LITERAL,\n    PLUS_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOT_SLASH,\n    NO_DOTS_SLASH,\n    QMARK,\n    QMARK_NO_DOT,\n    STAR,\n    START_ANCHOR\n  } = PLATFORM_CHARS;\n\n  const globstar = opts => {\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const nodot = opts.dot ? '' : NO_DOT;\n  const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;\n  let star = opts.bash === true ? globstar(opts) : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  } // minimatch options support\n\n\n  if (typeof opts.noext === 'boolean') {\n    opts.noextglob = opts.noext;\n  }\n\n  const state = {\n    input,\n    index: -1,\n    start: 0,\n    dot: opts.dot === true,\n    consumed: '',\n    output: '',\n    prefix: '',\n    backtrack: false,\n    negated: false,\n    brackets: 0,\n    braces: 0,\n    parens: 0,\n    quotes: 0,\n    globstar: false,\n    tokens\n  };\n  input = utils.removePrefix(input, state);\n  len = input.length;\n  const extglobs = [];\n  const braces = [];\n  const stack = [];\n  let prev = bos;\n  let value;\n  /**\n   * Tokenizing helpers\n   */\n\n  const eos = () => state.index === len - 1;\n\n  const peek = state.peek = (n = 1) => input[state.index + n];\n\n  const advance = state.advance = () => input[++state.index];\n\n  const remaining = () => input.slice(state.index + 1);\n\n  const consume = (value = '', num = 0) => {\n    state.consumed += value;\n    state.index += num;\n  };\n\n  const append = token => {\n    state.output += token.output != null ? token.output : token.value;\n    consume(token.value);\n  };\n\n  const negate = () => {\n    let count = 1;\n\n    while (peek() === '!' && (peek(2) !== '(' || peek(3) === '?')) {\n      advance();\n      state.start++;\n      count++;\n    }\n\n    if (count % 2 === 0) {\n      return false;\n    }\n\n    state.negated = true;\n    state.start++;\n    return true;\n  };\n\n  const increment = type => {\n    state[type]++;\n    stack.push(type);\n  };\n\n  const decrement = type => {\n    state[type]--;\n    stack.pop();\n  };\n  /**\n   * Push tokens onto the tokens array. This helper speeds up\n   * tokenizing by 1) helping us avoid backtracking as much as possible,\n   * and 2) helping us avoid creating extra tokens when consecutive\n   * characters are plain text. This improves performance and simplifies\n   * lookbehinds.\n   */\n\n\n  const push = tok => {\n    if (prev.type === 'globstar') {\n      const isBrace = state.braces > 0 && (tok.type === 'comma' || tok.type === 'brace');\n      const isExtglob = tok.extglob === true || extglobs.length && (tok.type === 'pipe' || tok.type === 'paren');\n\n      if (tok.type !== 'slash' && tok.type !== 'paren' && !isBrace && !isExtglob) {\n        state.output = state.output.slice(0, -prev.output.length);\n        prev.type = 'star';\n        prev.value = '*';\n        prev.output = star;\n        state.output += prev.output;\n      }\n    }\n\n    if (extglobs.length && tok.type !== 'paren' && !EXTGLOB_CHARS[tok.value]) {\n      extglobs[extglobs.length - 1].inner += tok.value;\n    }\n\n    if (tok.value || tok.output) append(tok);\n\n    if (prev && prev.type === 'text' && tok.type === 'text') {\n      prev.value += tok.value;\n      prev.output = (prev.output || '') + tok.value;\n      return;\n    }\n\n    tok.prev = prev;\n    tokens.push(tok);\n    prev = tok;\n  };\n\n  const extglobOpen = (type, value) => {\n    const token = { ...EXTGLOB_CHARS[value],\n      conditions: 1,\n      inner: ''\n    };\n    token.prev = prev;\n    token.parens = state.parens;\n    token.output = state.output;\n    const output = (opts.capture ? '(' : '') + token.open;\n    increment('parens');\n    push({\n      type,\n      value,\n      output: state.output ? '' : ONE_CHAR\n    });\n    push({\n      type: 'paren',\n      extglob: true,\n      value: advance(),\n      output\n    });\n    extglobs.push(token);\n  };\n\n  const extglobClose = token => {\n    let output = token.close + (opts.capture ? ')' : '');\n\n    if (token.type === 'negate') {\n      let extglobStar = star;\n\n      if (token.inner && token.inner.length > 1 && token.inner.includes('/')) {\n        extglobStar = globstar(opts);\n      }\n\n      if (extglobStar !== star || eos() || /^\\)+$/.test(remaining())) {\n        output = token.close = `)$))${extglobStar}`;\n      }\n\n      if (token.prev.type === 'bos' && eos()) {\n        state.negatedExtglob = true;\n      }\n    }\n\n    push({\n      type: 'paren',\n      extglob: true,\n      value,\n      output\n    });\n    decrement('parens');\n  };\n  /**\n   * Fast paths\n   */\n\n\n  if (opts.fastpaths !== false && !/(^[*!]|[/()[\\]{}\"])/.test(input)) {\n    let backslashes = false;\n    let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {\n      if (first === '\\\\') {\n        backslashes = true;\n        return m;\n      }\n\n      if (first === '?') {\n        if (esc) {\n          return esc + first + (rest ? QMARK.repeat(rest.length) : '');\n        }\n\n        if (index === 0) {\n          return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : '');\n        }\n\n        return QMARK.repeat(chars.length);\n      }\n\n      if (first === '.') {\n        return DOT_LITERAL.repeat(chars.length);\n      }\n\n      if (first === '*') {\n        if (esc) {\n          return esc + first + (rest ? star : '');\n        }\n\n        return star;\n      }\n\n      return esc ? m : `\\\\${m}`;\n    });\n\n    if (backslashes === true) {\n      if (opts.unescape === true) {\n        output = output.replace(/\\\\/g, '');\n      } else {\n        output = output.replace(/\\\\+/g, m => {\n          return m.length % 2 === 0 ? '\\\\\\\\' : m ? '\\\\' : '';\n        });\n      }\n    }\n\n    if (output === input && opts.contains === true) {\n      state.output = input;\n      return state;\n    }\n\n    state.output = utils.wrapOutput(output, state, options);\n    return state;\n  }\n  /**\n   * Tokenize input until we reach end-of-string\n   */\n\n\n  while (!eos()) {\n    value = advance();\n\n    if (value === '\\u0000') {\n      continue;\n    }\n    /**\n     * Escaped characters\n     */\n\n\n    if (value === '\\\\') {\n      const next = peek();\n\n      if (next === '/' && opts.bash !== true) {\n        continue;\n      }\n\n      if (next === '.' || next === ';') {\n        continue;\n      }\n\n      if (!next) {\n        value += '\\\\';\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      } // collapse slashes to reduce potential for exploits\n\n\n      const match = /^\\\\+/.exec(remaining());\n      let slashes = 0;\n\n      if (match && match[0].length > 2) {\n        slashes = match[0].length;\n        state.index += slashes;\n\n        if (slashes % 2 !== 0) {\n          value += '\\\\';\n        }\n      }\n\n      if (opts.unescape === true) {\n        value = advance() || '';\n      } else {\n        value += advance() || '';\n      }\n\n      if (state.brackets === 0) {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n    }\n    /**\n     * If we're inside a regex character class, continue\n     * until we reach the closing bracket.\n     */\n\n\n    if (state.brackets > 0 && (value !== ']' || prev.value === '[' || prev.value === '[^')) {\n      if (opts.posix !== false && value === ':') {\n        const inner = prev.value.slice(1);\n\n        if (inner.includes('[')) {\n          prev.posix = true;\n\n          if (inner.includes(':')) {\n            const idx = prev.value.lastIndexOf('[');\n            const pre = prev.value.slice(0, idx);\n            const rest = prev.value.slice(idx + 2);\n            const posix = POSIX_REGEX_SOURCE$1[rest];\n\n            if (posix) {\n              prev.value = pre + posix;\n              state.backtrack = true;\n              advance();\n\n              if (!bos.output && tokens.indexOf(prev) === 1) {\n                bos.output = ONE_CHAR;\n              }\n\n              continue;\n            }\n          }\n        }\n      }\n\n      if (value === '[' && peek() !== ':' || value === '-' && peek() === ']') {\n        value = `\\\\${value}`;\n      }\n\n      if (value === ']' && (prev.value === '[' || prev.value === '[^')) {\n        value = `\\\\${value}`;\n      }\n\n      if (opts.posix === true && value === '!' && prev.value === '[') {\n        value = '^';\n      }\n\n      prev.value += value;\n      append({\n        value\n      });\n      continue;\n    }\n    /**\n     * If we're inside a quoted string, continue\n     * until we reach the closing double quote.\n     */\n\n\n    if (state.quotes === 1 && value !== '\"') {\n      value = utils.escapeRegex(value);\n      prev.value += value;\n      append({\n        value\n      });\n      continue;\n    }\n    /**\n     * Double quotes\n     */\n\n\n    if (value === '\"') {\n      state.quotes = state.quotes === 1 ? 0 : 1;\n\n      if (opts.keepQuotes === true) {\n        push({\n          type: 'text',\n          value\n        });\n      }\n\n      continue;\n    }\n    /**\n     * Parentheses\n     */\n\n\n    if (value === '(') {\n      increment('parens');\n      push({\n        type: 'paren',\n        value\n      });\n      continue;\n    }\n\n    if (value === ')') {\n      if (state.parens === 0 && opts.strictBrackets === true) {\n        throw new SyntaxError(syntaxError('opening', '('));\n      }\n\n      const extglob = extglobs[extglobs.length - 1];\n\n      if (extglob && state.parens === extglob.parens + 1) {\n        extglobClose(extglobs.pop());\n        continue;\n      }\n\n      push({\n        type: 'paren',\n        value,\n        output: state.parens ? ')' : '\\\\)'\n      });\n      decrement('parens');\n      continue;\n    }\n    /**\n     * Square brackets\n     */\n\n\n    if (value === '[') {\n      if (opts.nobracket === true || !remaining().includes(']')) {\n        if (opts.nobracket !== true && opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('closing', ']'));\n        }\n\n        value = `\\\\${value}`;\n      } else {\n        increment('brackets');\n      }\n\n      push({\n        type: 'bracket',\n        value\n      });\n      continue;\n    }\n\n    if (value === ']') {\n      if (opts.nobracket === true || prev && prev.type === 'bracket' && prev.value.length === 1) {\n        push({\n          type: 'text',\n          value,\n          output: `\\\\${value}`\n        });\n        continue;\n      }\n\n      if (state.brackets === 0) {\n        if (opts.strictBrackets === true) {\n          throw new SyntaxError(syntaxError('opening', '['));\n        }\n\n        push({\n          type: 'text',\n          value,\n          output: `\\\\${value}`\n        });\n        continue;\n      }\n\n      decrement('brackets');\n      const prevValue = prev.value.slice(1);\n\n      if (prev.posix !== true && prevValue[0] === '^' && !prevValue.includes('/')) {\n        value = `/${value}`;\n      }\n\n      prev.value += value;\n      append({\n        value\n      }); // when literal brackets are explicitly disabled\n      // assume we should match with a regex character class\n\n      if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {\n        continue;\n      }\n\n      const escaped = utils.escapeRegex(prev.value);\n      state.output = state.output.slice(0, -prev.value.length); // when literal brackets are explicitly enabled\n      // assume we should escape the brackets to match literal characters\n\n      if (opts.literalBrackets === true) {\n        state.output += escaped;\n        prev.value = escaped;\n        continue;\n      } // when the user specifies nothing, try to match both\n\n\n      prev.value = `(${capture}${escaped}|${prev.value})`;\n      state.output += prev.value;\n      continue;\n    }\n    /**\n     * Braces\n     */\n\n\n    if (value === '{' && opts.nobrace !== true) {\n      increment('braces');\n      const open = {\n        type: 'brace',\n        value,\n        output: '(',\n        outputIndex: state.output.length,\n        tokensIndex: state.tokens.length\n      };\n      braces.push(open);\n      push(open);\n      continue;\n    }\n\n    if (value === '}') {\n      const brace = braces[braces.length - 1];\n\n      if (opts.nobrace === true || !brace) {\n        push({\n          type: 'text',\n          value,\n          output: value\n        });\n        continue;\n      }\n\n      let output = ')';\n\n      if (brace.dots === true) {\n        const arr = tokens.slice();\n        const range = [];\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n          tokens.pop();\n\n          if (arr[i].type === 'brace') {\n            break;\n          }\n\n          if (arr[i].type !== 'dots') {\n            range.unshift(arr[i].value);\n          }\n        }\n\n        output = expandRange(range, opts);\n        state.backtrack = true;\n      }\n\n      if (brace.comma !== true && brace.dots !== true) {\n        const out = state.output.slice(0, brace.outputIndex);\n        const toks = state.tokens.slice(brace.tokensIndex);\n        brace.value = brace.output = '\\\\{';\n        value = output = '\\\\}';\n        state.output = out;\n\n        for (const t of toks) {\n          state.output += t.output || t.value;\n        }\n      }\n\n      push({\n        type: 'brace',\n        value,\n        output\n      });\n      decrement('braces');\n      braces.pop();\n      continue;\n    }\n    /**\n     * Pipes\n     */\n\n\n    if (value === '|') {\n      if (extglobs.length > 0) {\n        extglobs[extglobs.length - 1].conditions++;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Commas\n     */\n\n\n    if (value === ',') {\n      let output = value;\n      const brace = braces[braces.length - 1];\n\n      if (brace && stack[stack.length - 1] === 'braces') {\n        brace.comma = true;\n        output = '|';\n      }\n\n      push({\n        type: 'comma',\n        value,\n        output\n      });\n      continue;\n    }\n    /**\n     * Slashes\n     */\n\n\n    if (value === '/') {\n      // if the beginning of the glob is \"./\", advance the start\n      // to the current index, and don't add the \"./\" characters\n      // to the state. This greatly simplifies lookbehinds when\n      // checking for BOS characters like \"!\" and \".\" (not \"./\")\n      if (prev.type === 'dot' && state.index === state.start + 1) {\n        state.start = state.index + 1;\n        state.consumed = '';\n        state.output = '';\n        tokens.pop();\n        prev = bos; // reset \"prev\" to the first token\n\n        continue;\n      }\n\n      push({\n        type: 'slash',\n        value,\n        output: SLASH_LITERAL\n      });\n      continue;\n    }\n    /**\n     * Dots\n     */\n\n\n    if (value === '.') {\n      if (state.braces > 0 && prev.type === 'dot') {\n        if (prev.value === '.') prev.output = DOT_LITERAL;\n        const brace = braces[braces.length - 1];\n        prev.type = 'dots';\n        prev.output += value;\n        prev.value += value;\n        brace.dots = true;\n        continue;\n      }\n\n      if (state.braces + state.parens === 0 && prev.type !== 'bos' && prev.type !== 'slash') {\n        push({\n          type: 'text',\n          value,\n          output: DOT_LITERAL\n        });\n        continue;\n      }\n\n      push({\n        type: 'dot',\n        value,\n        output: DOT_LITERAL\n      });\n      continue;\n    }\n    /**\n     * Question marks\n     */\n\n\n    if (value === '?') {\n      const isGroup = prev && prev.value === '(';\n\n      if (!isGroup && opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('qmark', value);\n        continue;\n      }\n\n      if (prev && prev.type === 'paren') {\n        const next = peek();\n        let output = value;\n\n        if (next === '<' && !utils.supportsLookbehinds()) {\n          throw new Error('Node.js v10 or higher is required for regex lookbehinds');\n        }\n\n        if (prev.value === '(' && !/[!=<:]/.test(next) || next === '<' && !/<([!=]|\\w+>)/.test(remaining())) {\n          output = `\\\\${value}`;\n        }\n\n        push({\n          type: 'text',\n          value,\n          output\n        });\n        continue;\n      }\n\n      if (opts.dot !== true && (prev.type === 'slash' || prev.type === 'bos')) {\n        push({\n          type: 'qmark',\n          value,\n          output: QMARK_NO_DOT\n        });\n        continue;\n      }\n\n      push({\n        type: 'qmark',\n        value,\n        output: QMARK\n      });\n      continue;\n    }\n    /**\n     * Exclamation\n     */\n\n\n    if (value === '!') {\n      if (opts.noextglob !== true && peek() === '(') {\n        if (peek(2) !== '?' || !/[!=<:]/.test(peek(3))) {\n          extglobOpen('negate', value);\n          continue;\n        }\n      }\n\n      if (opts.nonegate !== true && state.index === 0) {\n        negate();\n        continue;\n      }\n    }\n    /**\n     * Plus\n     */\n\n\n    if (value === '+') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        extglobOpen('plus', value);\n        continue;\n      }\n\n      if (prev && prev.value === '(' || opts.regex === false) {\n        push({\n          type: 'plus',\n          value,\n          output: PLUS_LITERAL\n        });\n        continue;\n      }\n\n      if (prev && (prev.type === 'bracket' || prev.type === 'paren' || prev.type === 'brace') || state.parens > 0) {\n        push({\n          type: 'plus',\n          value\n        });\n        continue;\n      }\n\n      push({\n        type: 'plus',\n        value: PLUS_LITERAL\n      });\n      continue;\n    }\n    /**\n     * Plain text\n     */\n\n\n    if (value === '@') {\n      if (opts.noextglob !== true && peek() === '(' && peek(2) !== '?') {\n        push({\n          type: 'at',\n          extglob: true,\n          value,\n          output: ''\n        });\n        continue;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Plain text\n     */\n\n\n    if (value !== '*') {\n      if (value === '$' || value === '^') {\n        value = `\\\\${value}`;\n      }\n\n      const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());\n\n      if (match) {\n        value += match[0];\n        state.index += match[0].length;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Stars\n     */\n\n\n    if (prev && (prev.type === 'globstar' || prev.star === true)) {\n      prev.type = 'star';\n      prev.star = true;\n      prev.value += value;\n      prev.output = star;\n      state.backtrack = true;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    let rest = remaining();\n\n    if (opts.noextglob !== true && /^\\([^?]/.test(rest)) {\n      extglobOpen('star', value);\n      continue;\n    }\n\n    if (prev.type === 'star') {\n      if (opts.noglobstar === true) {\n        consume(value);\n        continue;\n      }\n\n      const prior = prev.prev;\n      const before = prior.prev;\n      const isStart = prior.type === 'slash' || prior.type === 'bos';\n      const afterStar = before && (before.type === 'star' || before.type === 'globstar');\n\n      if (opts.bash === true && (!isStart || rest[0] && rest[0] !== '/')) {\n        push({\n          type: 'star',\n          value,\n          output: ''\n        });\n        continue;\n      }\n\n      const isBrace = state.braces > 0 && (prior.type === 'comma' || prior.type === 'brace');\n      const isExtglob = extglobs.length && (prior.type === 'pipe' || prior.type === 'paren');\n\n      if (!isStart && prior.type !== 'paren' && !isBrace && !isExtglob) {\n        push({\n          type: 'star',\n          value,\n          output: ''\n        });\n        continue;\n      } // strip consecutive `/**/`\n\n\n      while (rest.slice(0, 3) === '/**') {\n        const after = input[state.index + 4];\n\n        if (after && after !== '/') {\n          break;\n        }\n\n        rest = rest.slice(3);\n        consume('/**', 3);\n      }\n\n      if (prior.type === 'bos' && eos()) {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = globstar(opts);\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && !afterStar && eos()) {\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n        prev.type = 'globstar';\n        prev.output = globstar(opts) + (opts.strictSlashes ? ')' : '|$)');\n        prev.value += value;\n        state.globstar = true;\n        state.output += prior.output + prev.output;\n        consume(value);\n        continue;\n      }\n\n      if (prior.type === 'slash' && prior.prev.type !== 'bos' && rest[0] === '/') {\n        const end = rest[1] !== void 0 ? '|$' : '';\n        state.output = state.output.slice(0, -(prior.output + prev.output).length);\n        prior.output = `(?:${prior.output}`;\n        prev.type = 'globstar';\n        prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;\n        prev.value += value;\n        state.output += prior.output + prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({\n          type: 'slash',\n          value: '/',\n          output: ''\n        });\n        continue;\n      }\n\n      if (prior.type === 'bos' && rest[0] === '/') {\n        prev.type = 'globstar';\n        prev.value += value;\n        prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;\n        state.output = prev.output;\n        state.globstar = true;\n        consume(value + advance());\n        push({\n          type: 'slash',\n          value: '/',\n          output: ''\n        });\n        continue;\n      } // remove single star from output\n\n\n      state.output = state.output.slice(0, -prev.output.length); // reset previous token to globstar\n\n      prev.type = 'globstar';\n      prev.output = globstar(opts);\n      prev.value += value; // reset output with globstar\n\n      state.output += prev.output;\n      state.globstar = true;\n      consume(value);\n      continue;\n    }\n\n    const token = {\n      type: 'star',\n      value,\n      output: star\n    };\n\n    if (opts.bash === true) {\n      token.output = '.*?';\n\n      if (prev.type === 'bos' || prev.type === 'slash') {\n        token.output = nodot + token.output;\n      }\n\n      push(token);\n      continue;\n    }\n\n    if (prev && (prev.type === 'bracket' || prev.type === 'paren') && opts.regex === true) {\n      token.output = value;\n      push(token);\n      continue;\n    }\n\n    if (state.index === state.start || prev.type === 'slash' || prev.type === 'dot') {\n      if (prev.type === 'dot') {\n        state.output += NO_DOT_SLASH;\n        prev.output += NO_DOT_SLASH;\n      } else if (opts.dot === true) {\n        state.output += NO_DOTS_SLASH;\n        prev.output += NO_DOTS_SLASH;\n      } else {\n        state.output += nodot;\n        prev.output += nodot;\n      }\n\n      if (peek() !== '*') {\n        state.output += ONE_CHAR;\n        prev.output += ONE_CHAR;\n      }\n    }\n\n    push(token);\n  }\n\n  while (state.brackets > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ']'));\n    state.output = utils.escapeLast(state.output, '[');\n    decrement('brackets');\n  }\n\n  while (state.parens > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', ')'));\n    state.output = utils.escapeLast(state.output, '(');\n    decrement('parens');\n  }\n\n  while (state.braces > 0) {\n    if (opts.strictBrackets === true) throw new SyntaxError(syntaxError('closing', '}'));\n    state.output = utils.escapeLast(state.output, '{');\n    decrement('braces');\n  }\n\n  if (opts.strictSlashes !== true && (prev.type === 'star' || prev.type === 'bracket')) {\n    push({\n      type: 'maybe_slash',\n      value: '',\n      output: `${SLASH_LITERAL}?`\n    });\n  } // rebuild the output if we had to backtrack at any point\n\n\n  if (state.backtrack === true) {\n    state.output = '';\n\n    for (const token of state.tokens) {\n      state.output += token.output != null ? token.output : token.value;\n\n      if (token.suffix) {\n        state.output += token.suffix;\n      }\n    }\n  }\n\n  return state;\n};\n/**\n * Fast paths for creating regular expressions for common glob patterns.\n * This can significantly speed up processing and has very little downside\n * impact when none of the fast paths match.\n */\n\n\nparse.fastpaths = (input, options) => {\n  const opts = { ...options\n  };\n  const max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;\n  const len = input.length;\n\n  if (len > max) {\n    throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);\n  }\n\n  input = REPLACEMENTS[input] || input;\n  const win32 = utils.isWindows(options); // create constants based on platform, for windows or posix\n\n  const {\n    DOT_LITERAL,\n    SLASH_LITERAL,\n    ONE_CHAR,\n    DOTS_SLASH,\n    NO_DOT,\n    NO_DOTS,\n    NO_DOTS_SLASH,\n    STAR,\n    START_ANCHOR\n  } = constants.globChars(win32);\n  const nodot = opts.dot ? NO_DOTS : NO_DOT;\n  const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;\n  const capture = opts.capture ? '' : '?:';\n  const state = {\n    negated: false,\n    prefix: ''\n  };\n  let star = opts.bash === true ? '.*?' : STAR;\n\n  if (opts.capture) {\n    star = `(${star})`;\n  }\n\n  const globstar = opts => {\n    if (opts.noglobstar === true) return star;\n    return `(${capture}(?:(?!${START_ANCHOR}${opts.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;\n  };\n\n  const create = str => {\n    switch (str) {\n      case '*':\n        return `${nodot}${ONE_CHAR}${star}`;\n\n      case '.*':\n        return `${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*.*':\n        return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '*/*':\n        return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;\n\n      case '**':\n        return nodot + globstar(opts);\n\n      case '**/*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;\n\n      case '**/*.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      case '**/.*':\n        return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;\n\n      default:\n        {\n          const match = /^(.*?)\\.(\\w+)$/.exec(str);\n          if (!match) return;\n          const source = create(match[1]);\n          if (!source) return;\n          return source + DOT_LITERAL + match[2];\n        }\n    }\n  };\n\n  const output = utils.removePrefix(input, state);\n  let source = create(output);\n\n  if (source && opts.strictSlashes !== true) {\n    source += `${SLASH_LITERAL}?`;\n  }\n\n  return source;\n};\n\nvar parse_1 = parse;\n\nconst isObject = val => val && typeof val === 'object' && !Array.isArray(val);\n/**\n * Creates a matcher function from one or more glob patterns. The\n * returned function takes a string to match as its first argument,\n * and returns true if the string is a match. The returned matcher\n * function also takes a boolean as the second argument that, when true,\n * returns an object with additional information.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch(glob[, options]);\n *\n * const isMatch = picomatch('*.!(*a)');\n * console.log(isMatch('a.a')); //=> false\n * console.log(isMatch('a.b')); //=> true\n * ```\n * @name picomatch\n * @param {String|Array} `globs` One or more glob patterns.\n * @param {Object=} `options`\n * @return {Function=} Returns a matcher function.\n * @api public\n */\n\n\nconst picomatch = (glob, options, returnState = false) => {\n  if (Array.isArray(glob)) {\n    const fns = glob.map(input => picomatch(input, options, returnState));\n\n    const arrayMatcher = str => {\n      for (const isMatch of fns) {\n        const state = isMatch(str);\n        if (state) return state;\n      }\n\n      return false;\n    };\n\n    return arrayMatcher;\n  }\n\n  const isState = isObject(glob) && glob.tokens && glob.input;\n\n  if (glob === '' || typeof glob !== 'string' && !isState) {\n    throw new TypeError('Expected pattern to be a non-empty string');\n  }\n\n  const opts = options || {};\n  const posix = utils.isWindows(options);\n  const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);\n  const state = regex.state;\n  delete regex.state;\n\n  let isIgnored = () => false;\n\n  if (opts.ignore) {\n    const ignoreOpts = { ...options,\n      ignore: null,\n      onMatch: null,\n      onResult: null\n    };\n    isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);\n  }\n\n  const matcher = (input, returnObject = false) => {\n    const {\n      isMatch,\n      match,\n      output\n    } = picomatch.test(input, regex, options, {\n      glob,\n      posix\n    });\n    const result = {\n      glob,\n      state,\n      regex,\n      posix,\n      input,\n      output,\n      match,\n      isMatch\n    };\n\n    if (typeof opts.onResult === 'function') {\n      opts.onResult(result);\n    }\n\n    if (isMatch === false) {\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (isIgnored(input)) {\n      if (typeof opts.onIgnore === 'function') {\n        opts.onIgnore(result);\n      }\n\n      result.isMatch = false;\n      return returnObject ? result : false;\n    }\n\n    if (typeof opts.onMatch === 'function') {\n      opts.onMatch(result);\n    }\n\n    return returnObject ? result : true;\n  };\n\n  if (returnState) {\n    matcher.state = state;\n  }\n\n  return matcher;\n};\n/**\n * Test `input` with the given `regex`. This is used by the main\n * `picomatch()` function to test the input string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.test(input, regex[, options]);\n *\n * console.log(picomatch.test('foo/bar', /^(?:([^/]*?)\\/([^/]*?))$/));\n * // { isMatch: true, match: [ 'foo/', 'foo', 'bar' ], output: 'foo/bar' }\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp} `regex`\n * @return {Object} Returns an object with matching info.\n * @api public\n */\n\n\npicomatch.test = (input, regex, options, {\n  glob,\n  posix\n} = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected input to be a string');\n  }\n\n  if (input === '') {\n    return {\n      isMatch: false,\n      output: ''\n    };\n  }\n\n  const opts = options || {};\n  const format = opts.format || (posix ? utils.toPosixSlashes : null);\n  let match = input === glob;\n  let output = match && format ? format(input) : input;\n\n  if (match === false) {\n    output = format ? format(input) : input;\n    match = output === glob;\n  }\n\n  if (match === false || opts.capture === true) {\n    if (opts.matchBase === true || opts.basename === true) {\n      match = picomatch.matchBase(input, regex, options, posix);\n    } else {\n      match = regex.exec(output);\n    }\n  }\n\n  return {\n    isMatch: Boolean(match),\n    match,\n    output\n  };\n};\n/**\n * Match the basename of a filepath.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.matchBase(input, glob[, options]);\n * console.log(picomatch.matchBase('foo/bar.js', '*.js'); // true\n * ```\n * @param {String} `input` String to test.\n * @param {RegExp|String} `glob` Glob pattern or regex created by [.makeRe](#makeRe).\n * @return {Boolean}\n * @api public\n */\n\n\npicomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {\n  const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);\n  return regex.test(sysPath__default['default'].basename(input));\n};\n/**\n * Returns true if **any** of the given glob `patterns` match the specified `string`.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.isMatch(string, patterns[, options]);\n *\n * console.log(picomatch.isMatch('a.a', ['b.*', '*.a'])); //=> true\n * console.log(picomatch.isMatch('a.a', 'b.*')); //=> false\n * ```\n * @param {String|Array} str The string to test.\n * @param {String|Array} patterns One or more glob patterns to use for matching.\n * @param {Object} [options] See available [options](#options).\n * @return {Boolean} Returns true if any patterns match `str`\n * @api public\n */\n\n\npicomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);\n/**\n * Parse a glob pattern to create the source string for a regular\n * expression.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const result = picomatch.parse(pattern[, options]);\n * ```\n * @param {String} `pattern`\n * @param {Object} `options`\n * @return {Object} Returns an object with useful properties and output to be used as a regex source string.\n * @api public\n */\n\n\npicomatch.parse = (pattern, options) => {\n  if (Array.isArray(pattern)) return pattern.map(p => picomatch.parse(p, options));\n  return parse_1(pattern, { ...options,\n    fastpaths: false\n  });\n};\n/**\n * Scan a glob pattern to separate the pattern into segments.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.scan(input[, options]);\n *\n * const result = picomatch.scan('!./foo/*.js');\n * console.log(result);\n * { prefix: '!./',\n *   input: '!./foo/*.js',\n *   start: 3,\n *   base: 'foo',\n *   glob: '*.js',\n *   isBrace: false,\n *   isBracket: false,\n *   isGlob: true,\n *   isExtglob: false,\n *   isGlobstar: false,\n *   negated: true }\n * ```\n * @param {String} `input` Glob pattern to scan.\n * @param {Object} `options`\n * @return {Object} Returns an object with\n * @api public\n */\n\n\npicomatch.scan = (input, options) => scan_1(input, options);\n/**\n * Create a regular expression from a parsed glob pattern.\n *\n * ```js\n * const picomatch = require('picomatch');\n * const state = picomatch.parse('*.js');\n * // picomatch.compileRe(state[, options]);\n *\n * console.log(picomatch.compileRe(state));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `state` The object returned from the `.parse` method.\n * @param {Object} `options`\n * @return {RegExp} Returns a regex created from the given pattern.\n * @api public\n */\n\n\npicomatch.compileRe = (parsed, options, returnOutput = false, returnState = false) => {\n  if (returnOutput === true) {\n    return parsed.output;\n  }\n\n  const opts = options || {};\n  const prepend = opts.contains ? '' : '^';\n  const append = opts.contains ? '' : '$';\n  let source = `${prepend}(?:${parsed.output})${append}`;\n\n  if (parsed && parsed.negated === true) {\n    source = `^(?!${source}).*$`;\n  }\n\n  const regex = picomatch.toRegex(source, options);\n\n  if (returnState === true) {\n    regex.state = parsed;\n  }\n\n  return regex;\n};\n\npicomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {\n  if (!input || typeof input !== 'string') {\n    throw new TypeError('Expected a non-empty string');\n  }\n\n  const opts = options || {};\n  let parsed = {\n    negated: false,\n    fastpaths: true\n  };\n  let prefix = '';\n  let output;\n\n  if (input.startsWith('./')) {\n    input = input.slice(2);\n    prefix = parsed.prefix = './';\n  }\n\n  if (opts.fastpaths !== false && (input[0] === '.' || input[0] === '*')) {\n    output = parse_1.fastpaths(input, options);\n  }\n\n  if (output === undefined) {\n    parsed = parse_1(input, options);\n    parsed.prefix = prefix + (parsed.prefix || '');\n  } else {\n    parsed.output = output;\n  }\n\n  return picomatch.compileRe(parsed, options, returnOutput, returnState);\n};\n/**\n * Create a regular expression from the given regex source string.\n *\n * ```js\n * const picomatch = require('picomatch');\n * // picomatch.toRegex(source[, options]);\n *\n * const { output } = picomatch.parse('*.js');\n * console.log(picomatch.toRegex(output));\n * //=> /^(?:(?!\\.)(?=.)[^/]*?\\.js)$/\n * ```\n * @param {String} `source` Regular expression source string.\n * @param {Object} `options`\n * @return {RegExp}\n * @api public\n */\n\n\npicomatch.toRegex = (source, options) => {\n  try {\n    const opts = options || {};\n    return new RegExp(source, opts.flags || (opts.nocase ? 'i' : ''));\n  } catch (err) {\n    if (options && options.debug === true) throw err;\n    return /$^/;\n  }\n};\n/**\n * Picomatch constants.\n * @return {Object}\n */\n\n\npicomatch.constants = constants;\n/**\n * Expose \"picomatch\"\n */\n\nvar picomatch_1 = picomatch;\nvar picomatch$1 = picomatch_1;\nconst {\n  Readable\n} = require$$0__default$1['default'];\nconst {\n  promisify\n} = require$$0__default['default'];\nconst readdir = promisify(fs__default['default'].readdir);\nconst stat = promisify(fs__default['default'].stat);\nconst lstat = promisify(fs__default['default'].lstat);\nconst realpath = promisify(fs__default['default'].realpath);\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst BANG = '!';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP']);\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = error => NORMAL_FLOW_ERRORS.has(error.code);\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch$1(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n\n    for (const item of filter) {\n      const trimmed = item.trim();\n\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch$1(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch$1(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry => positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      }\n\n      return entry => !negative.some(f => f(entry.basename));\n    }\n\n    return entry => positive.some(f => f(entry.basename));\n  }\n};\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n\n      /* eslint-disable no-unused-vars */\n      fileFilter: path => true,\n      directoryFilter: path => true,\n\n      /* eslint-enable no-unused-vars */\n      type: FILE_TYPE,\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      autoDestroy: true,\n      highWaterMark: options.highWaterMark || 4096\n    });\n    const opts = { ...ReaddirpStream.defaultOptions,\n      ...options\n    };\n    const {\n      root,\n      type\n    } = opts;\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n    const statMethod = opts.lstat ? lstat : stat; // Use bigint stats if it's windows and stat() supports options (node 10+).\n\n    if (process.platform === 'win32' && stat.length === 3) {\n      this._stat = path => statMethod(path, {\n        bigint: true\n      });\n    } else {\n      this._stat = statMethod;\n    }\n\n    this._maxDepth = opts.depth;\n    this._wantsDir = [DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsFile = [FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE].includes(type);\n    this._wantsEverything = type === EVERYTHING_TYPE;\n    this._root = sysPath__default['default'].resolve(root);\n    this._isDirent = 'Dirent' in fs__default['default'] && !opts.alwaysStat;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._rdOptions = {\n      encoding: 'utf8',\n      withFileTypes: this._isDirent\n    }; // Launch stream with one parent, the root dir.\n\n    this.parents = [this._exploreDir(root, 1)];\n    this.reading = false;\n    this.parent = undefined;\n  }\n\n  async _read(batch) {\n    if (this.reading) return;\n    this.reading = true;\n\n    try {\n      while (!this.destroyed && batch > 0) {\n        const {\n          path,\n          depth,\n          files = []\n        } = this.parent || {};\n\n        if (files.length > 0) {\n          const slice = files.splice(0, batch).map(dirent => this._formatEntry(dirent, path));\n\n          for (const entry of await Promise.all(slice)) {\n            if (this.destroyed) return;\n            const entryType = await this._getEntryType(entry);\n\n            if (entryType === 'directory' && this._directoryFilter(entry)) {\n              if (depth <= this._maxDepth) {\n                this.parents.push(this._exploreDir(entry.fullPath, depth + 1));\n              }\n\n              if (this._wantsDir) {\n                this.push(entry);\n                batch--;\n              }\n            } else if ((entryType === 'file' || this._includeAsFile(entry)) && this._fileFilter(entry)) {\n              if (this._wantsFile) {\n                this.push(entry);\n                batch--;\n              }\n            }\n          }\n        } else {\n          const parent = this.parents.pop();\n\n          if (!parent) {\n            this.push(null);\n            break;\n          }\n\n          this.parent = await parent;\n          if (this.destroyed) return;\n        }\n      }\n    } catch (error) {\n      this.destroy(error);\n    } finally {\n      this.reading = false;\n    }\n  }\n\n  async _exploreDir(path, depth) {\n    let files;\n\n    try {\n      files = await readdir(path, this._rdOptions);\n    } catch (error) {\n      this._onError(error);\n    }\n\n    return {\n      files,\n      depth,\n      path\n    };\n  }\n\n  async _formatEntry(dirent, path) {\n    let entry;\n\n    try {\n      const basename = this._isDirent ? dirent.name : dirent;\n      const fullPath = sysPath__default['default'].resolve(sysPath__default['default'].join(path, basename));\n      entry = {\n        path: sysPath__default['default'].relative(this._root, fullPath),\n        fullPath,\n        basename\n      };\n      entry[this._statsProp] = this._isDirent ? dirent : await this._stat(fullPath);\n    } catch (err) {\n      this._onError(err);\n    }\n\n    return entry;\n  }\n\n  _onError(err) {\n    if (isNormalFlowError(err) && !this.destroyed) {\n      this.emit('warn', err);\n    } else {\n      this.destroy(err);\n    }\n  }\n\n  async _getEntryType(entry) {\n    // entry may be undefined, because a warning or an error were emitted\n    // and the statsProp is undefined\n    const stats = entry && entry[this._statsProp];\n\n    if (!stats) {\n      return;\n    }\n\n    if (stats.isFile()) {\n      return 'file';\n    }\n\n    if (stats.isDirectory()) {\n      return 'directory';\n    }\n\n    if (stats && stats.isSymbolicLink()) {\n      try {\n        const entryRealPath = await realpath(entry.fullPath);\n        const entryRealPathStats = await lstat(entryRealPath);\n\n        if (entryRealPathStats.isFile()) {\n          return 'file';\n        }\n\n        if (entryRealPathStats.isDirectory()) {\n          return 'directory';\n        }\n      } catch (error) {\n        this._onError(error);\n      }\n    }\n  }\n\n  _includeAsFile(entry) {\n    const stats = entry && entry[this._statsProp];\n    return stats && this._wantsEverything && !stats.isDirectory();\n  }\n\n}\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\n\n\nconst readdirp = (root, options = {}) => {\n  let type = options.entryType || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n\n  if (type) options.type = type;\n\n  if (!root) {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new TypeError('readdirp: root argument must be a string. Usage: readdirp(root, options)');\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(`readdirp: Invalid type passed. Use one of ${ALL_TYPES.join(', ')}`);\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options).on('data', entry => files.push(entry)).on('end', () => resolve(files)).on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\nvar readdirp_1 = readdirp;\n/*!\n * normalize-path <https://github.com/jonschlinkert/normalize-path>\n *\n * Copyright (c) 2014-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nvar normalizePath = function (path, stripTrailing) {\n  if (typeof path !== 'string') {\n    throw new TypeError('expected path to be a string');\n  }\n\n  if (path === '\\\\' || path === '/') return '/';\n  var len = path.length;\n  if (len <= 1) return path; // ensure that win32 namespaces has two leading slashes, so that the path is\n  // handled properly by the win32 version of path.parse() after being normalized\n  // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces\n\n  var prefix = '';\n\n  if (len > 4 && path[3] === '\\\\') {\n    var ch = path[2];\n\n    if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\\\\\') {\n      path = path.slice(2);\n      prefix = '//';\n    }\n  }\n\n  var segs = path.split(/[/\\\\]+/);\n\n  if (stripTrailing !== false && segs[segs.length - 1] === '') {\n    segs.pop();\n  }\n\n  return prefix + segs.join('/');\n};\n\nvar anymatch_1 = createCommonjsModule(function (module, exports) {\n  Object.defineProperty(exports, \"__esModule\", {\n    value: true\n  });\n  /**\n   * @typedef {(testString: string) => boolean} AnymatchFn\n   * @typedef {string|RegExp|AnymatchFn} AnymatchPattern\n   * @typedef {AnymatchPattern|AnymatchPattern[]} AnymatchMatcher\n   */\n\n  const BANG = '!';\n  const DEFAULT_OPTIONS = {\n    returnIndex: false\n  };\n\n  const arrify = item => Array.isArray(item) ? item : [item];\n  /**\n   * @param {AnymatchPattern} matcher\n   * @param {object} options\n   * @returns {AnymatchFn}\n   */\n\n\n  const createPattern = (matcher, options) => {\n    if (typeof matcher === 'function') {\n      return matcher;\n    }\n\n    if (typeof matcher === 'string') {\n      const glob = picomatch$1(matcher, options);\n      return string => matcher === string || glob(string);\n    }\n\n    if (matcher instanceof RegExp) {\n      return string => matcher.test(string);\n    }\n\n    return string => false;\n  };\n  /**\n   * @param {Array<Function>} patterns\n   * @param {Array<Function>} negPatterns\n   * @param {String|Array} args\n   * @param {Boolean} returnIndex\n   * @returns {boolean|number}\n   */\n\n\n  const matchPatterns = (patterns, negPatterns, args, returnIndex) => {\n    const isList = Array.isArray(args);\n\n    const _path = isList ? args[0] : args;\n\n    if (!isList && typeof _path !== 'string') {\n      throw new TypeError('anymatch: second argument must be a string: got ' + Object.prototype.toString.call(_path));\n    }\n\n    const path = normalizePath(_path);\n\n    for (let index = 0; index < negPatterns.length; index++) {\n      const nglob = negPatterns[index];\n\n      if (nglob(path)) {\n        return returnIndex ? -1 : false;\n      }\n    }\n\n    const applied = isList && [path].concat(args.slice(1));\n\n    for (let index = 0; index < patterns.length; index++) {\n      const pattern = patterns[index];\n\n      if (isList ? pattern(...applied) : pattern(path)) {\n        return returnIndex ? index : true;\n      }\n    }\n\n    return returnIndex ? -1 : false;\n  };\n  /**\n   * @param {AnymatchMatcher} matchers\n   * @param {Array|string} testString\n   * @param {object} options\n   * @returns {boolean|number|Function}\n   */\n\n\n  const anymatch = (matchers, testString, options = DEFAULT_OPTIONS) => {\n    if (matchers == null) {\n      throw new TypeError('anymatch: specify first argument');\n    }\n\n    const opts = typeof options === 'boolean' ? {\n      returnIndex: options\n    } : options;\n    const returnIndex = opts.returnIndex || false; // Early cache for matchers.\n\n    const mtchers = arrify(matchers);\n    const negatedGlobs = mtchers.filter(item => typeof item === 'string' && item.charAt(0) === BANG).map(item => item.slice(1)).map(item => picomatch$1(item, opts));\n    const patterns = mtchers.map(matcher => createPattern(matcher, opts));\n\n    if (testString == null) {\n      return (testString, ri = false) => {\n        const returnIndex = typeof ri === 'boolean' ? ri : false;\n        return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n      };\n    }\n\n    return matchPatterns(patterns, negatedGlobs, testString, returnIndex);\n  };\n\n  anymatch.default = anymatch;\n  module.exports = anymatch;\n});\n/*!\n * is-extglob <https://github.com/jonschlinkert/is-extglob>\n *\n * Copyright (c) 2014-2016, Jon Schlinkert.\n * Licensed under the MIT License.\n */\n\nvar isExtglob = function isExtglob(str) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  var match;\n\n  while (match = /(\\\\).|([@?!+*]\\(.*\\))/g.exec(str)) {\n    if (match[2]) return true;\n    str = str.slice(match.index + match[0].length);\n  }\n\n  return false;\n};\n/*!\n * is-glob <https://github.com/jonschlinkert/is-glob>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\nvar chars = {\n  '{': '}',\n  '(': ')',\n  '[': ']'\n};\nvar strictRegex = /\\\\(.)|(^!|\\*|[\\].+)]\\?|\\[[^\\\\\\]]+\\]|\\{[^\\\\}]+\\}|\\(\\?[:!=][^\\\\)]+\\)|\\([^|]+\\|[^\\\\)]+\\))/;\nvar relaxedRegex = /\\\\(.)|(^!|[*?{}()[\\]]|\\(\\?)/;\n\nvar isGlob = function isGlob(str, options) {\n  if (typeof str !== 'string' || str === '') {\n    return false;\n  }\n\n  if (isExtglob(str)) {\n    return true;\n  }\n\n  var regex = strictRegex;\n  var match; // optionally relax regex\n\n  if (options && options.strict === false) {\n    regex = relaxedRegex;\n  }\n\n  while (match = regex.exec(str)) {\n    if (match[2]) return true;\n    var idx = match.index + match[0].length; // if an open bracket/brace/paren is escaped,\n    // set the index to the next closing character\n\n    var open = match[1];\n    var close = open ? chars[open] : null;\n\n    if (open && close) {\n      var n = str.indexOf(close, idx);\n\n      if (n !== -1) {\n        idx = n + 1;\n      }\n    }\n\n    str = str.slice(idx);\n  }\n\n  return false;\n};\n\nvar pathPosixDirname = sysPath__default['default'].posix.dirname;\nvar isWin32 = require$$1__default['default'].platform() === 'win32';\nvar slash = '/';\nvar backslash = /\\\\/g;\nvar enclosure = /[\\{\\[].*[\\/]*.*[\\}\\]]$/;\nvar globby = /(^|[^\\\\])([\\{\\[]|\\([^\\)]+$)/;\nvar escaped = /\\\\([\\!\\*\\?\\|\\[\\]\\(\\)\\{\\}])/g;\n/**\n * @param {string} str\n * @param {Object} opts\n * @param {boolean} [opts.flipBackslashes=true]\n */\n\nvar globParent = function globParent(str, opts) {\n  var options = Object.assign({\n    flipBackslashes: true\n  }, opts); // flip windows path separators\n\n  if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {\n    str = str.replace(backslash, slash);\n  } // special case for strings ending in enclosure containing path separator\n\n\n  if (enclosure.test(str)) {\n    str += slash;\n  } // preserves full path in case of trailing path separator\n\n\n  str += 'a'; // remove path parts that are globby\n\n  do {\n    str = pathPosixDirname(str);\n  } while (isGlob(str) || globby.test(str)); // remove escape chars and return result\n\n\n  return str.replace(escaped, '$1');\n};\n\nvar utils$1 = createCommonjsModule(function (module, exports) {\n  exports.isInteger = num => {\n    if (typeof num === 'number') {\n      return Number.isInteger(num);\n    }\n\n    if (typeof num === 'string' && num.trim() !== '') {\n      return Number.isInteger(Number(num));\n    }\n\n    return false;\n  };\n  /**\n   * Find a node of the given type\n   */\n\n\n  exports.find = (node, type) => node.nodes.find(node => node.type === type);\n  /**\n   * Find a node of the given type\n   */\n\n\n  exports.exceedsLimit = (min, max, step = 1, limit) => {\n    if (limit === false) return false;\n    if (!exports.isInteger(min) || !exports.isInteger(max)) return false;\n    return (Number(max) - Number(min)) / Number(step) >= limit;\n  };\n  /**\n   * Escape the given node with '\\\\' before node.value\n   */\n\n\n  exports.escapeNode = (block, n = 0, type) => {\n    let node = block.nodes[n];\n    if (!node) return;\n\n    if (type && node.type === type || node.type === 'open' || node.type === 'close') {\n      if (node.escaped !== true) {\n        node.value = '\\\\' + node.value;\n        node.escaped = true;\n      }\n    }\n  };\n  /**\n   * Returns true if the given brace node should be enclosed in literal braces\n   */\n\n\n  exports.encloseBrace = node => {\n    if (node.type !== 'brace') return false;\n\n    if (node.commas >> 0 + node.ranges >> 0 === 0) {\n      node.invalid = true;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if a brace node is invalid.\n   */\n\n\n  exports.isInvalidBrace = block => {\n    if (block.type !== 'brace') return false;\n    if (block.invalid === true || block.dollar) return true;\n\n    if (block.commas >> 0 + block.ranges >> 0 === 0) {\n      block.invalid = true;\n      return true;\n    }\n\n    if (block.open !== true || block.close !== true) {\n      block.invalid = true;\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * Returns true if a node is an open or close node\n   */\n\n\n  exports.isOpenOrClose = node => {\n    if (node.type === 'open' || node.type === 'close') {\n      return true;\n    }\n\n    return node.open === true || node.close === true;\n  };\n  /**\n   * Reduce an array of text nodes.\n   */\n\n\n  exports.reduce = nodes => nodes.reduce((acc, node) => {\n    if (node.type === 'text') acc.push(node.value);\n    if (node.type === 'range') node.type = 'text';\n    return acc;\n  }, []);\n  /**\n   * Flatten an array\n   */\n\n\n  exports.flatten = (...args) => {\n    const result = [];\n\n    const flat = arr => {\n      for (let i = 0; i < arr.length; i++) {\n        let ele = arr[i];\n        Array.isArray(ele) ? flat(ele) : ele !== void 0 && result.push(ele);\n      }\n\n      return result;\n    };\n\n    flat(args);\n    return result;\n  };\n});\n\nvar stringify = (ast, options = {}) => {\n  let stringify = (node, parent = {}) => {\n    let invalidBlock = options.escapeInvalid && utils$1.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let output = '';\n\n    if (node.value) {\n      if ((invalidBlock || invalidNode) && utils$1.isOpenOrClose(node)) {\n        return '\\\\' + node.value;\n      }\n\n      return node.value;\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += stringify(child);\n      }\n    }\n\n    return output;\n  };\n\n  return stringify(ast);\n};\n/*!\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n\nvar isNumber = function (num) {\n  if (typeof num === 'number') {\n    return num - num === 0;\n  }\n\n  if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);\n  }\n\n  return false;\n};\n\nconst toRegexRange = (min, max, options) => {\n  if (isNumber(min) === false) {\n    throw new TypeError('toRegexRange: expected the first argument to be a number');\n  }\n\n  if (max === void 0 || min === max) {\n    return String(min);\n  }\n\n  if (isNumber(max) === false) {\n    throw new TypeError('toRegexRange: expected the second argument to be a number.');\n  }\n\n  let opts = {\n    relaxZeros: true,\n    ...options\n  };\n\n  if (typeof opts.strictZeros === 'boolean') {\n    opts.relaxZeros = opts.strictZeros === false;\n  }\n\n  let relax = String(opts.relaxZeros);\n  let shorthand = String(opts.shorthand);\n  let capture = String(opts.capture);\n  let wrap = String(opts.wrap);\n  let cacheKey = min + ':' + max + '=' + relax + shorthand + capture + wrap;\n\n  if (toRegexRange.cache.hasOwnProperty(cacheKey)) {\n    return toRegexRange.cache[cacheKey].result;\n  }\n\n  let a = Math.min(min, max);\n  let b = Math.max(min, max);\n\n  if (Math.abs(a - b) === 1) {\n    let result = min + '|' + max;\n\n    if (opts.capture) {\n      return `(${result})`;\n    }\n\n    if (opts.wrap === false) {\n      return result;\n    }\n\n    return `(?:${result})`;\n  }\n\n  let isPadded = hasPadding(min) || hasPadding(max);\n  let state = {\n    min,\n    max,\n    a,\n    b\n  };\n  let positives = [];\n  let negatives = [];\n\n  if (isPadded) {\n    state.isPadded = isPadded;\n    state.maxLen = String(state.max).length;\n  }\n\n  if (a < 0) {\n    let newMin = b < 0 ? Math.abs(b) : 1;\n    negatives = splitToPatterns(newMin, Math.abs(a), state, opts);\n    a = state.a = 0;\n  }\n\n  if (b >= 0) {\n    positives = splitToPatterns(a, b, state, opts);\n  }\n\n  state.negatives = negatives;\n  state.positives = positives;\n  state.result = collatePatterns(negatives, positives);\n\n  if (opts.capture === true) {\n    state.result = `(${state.result})`;\n  } else if (opts.wrap !== false && positives.length + negatives.length > 1) {\n    state.result = `(?:${state.result})`;\n  }\n\n  toRegexRange.cache[cacheKey] = state;\n  return state.result;\n};\n\nfunction collatePatterns(neg, pos, options) {\n  let onlyNegative = filterPatterns(neg, pos, '-', false) || [];\n  let onlyPositive = filterPatterns(pos, neg, '', false) || [];\n  let intersected = filterPatterns(neg, pos, '-?', true) || [];\n  let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);\n  return subpatterns.join('|');\n}\n\nfunction splitToRanges(min, max) {\n  let nines = 1;\n  let zeros = 1;\n  let stop = countNines(min, nines);\n  let stops = new Set([max]);\n\n  while (min <= stop && stop <= max) {\n    stops.add(stop);\n    nines += 1;\n    stop = countNines(min, nines);\n  }\n\n  stop = countZeros(max + 1, zeros) - 1;\n\n  while (min < stop && stop <= max) {\n    stops.add(stop);\n    zeros += 1;\n    stop = countZeros(max + 1, zeros) - 1;\n  }\n\n  stops = [...stops];\n  stops.sort(compare);\n  return stops;\n}\n/**\n * Convert a range to a regex pattern\n * @param {Number} `start`\n * @param {Number} `stop`\n * @return {String}\n */\n\n\nfunction rangeToPattern(start, stop, options) {\n  if (start === stop) {\n    return {\n      pattern: start,\n      count: [],\n      digits: 0\n    };\n  }\n\n  let zipped = zip(start, stop);\n  let digits = zipped.length;\n  let pattern = '';\n  let count = 0;\n\n  for (let i = 0; i < digits; i++) {\n    let [startDigit, stopDigit] = zipped[i];\n\n    if (startDigit === stopDigit) {\n      pattern += startDigit;\n    } else if (startDigit !== '0' || stopDigit !== '9') {\n      pattern += toCharacterClass(startDigit, stopDigit);\n    } else {\n      count++;\n    }\n  }\n\n  if (count) {\n    pattern += options.shorthand === true ? '\\\\d' : '[0-9]';\n  }\n\n  return {\n    pattern,\n    count: [count],\n    digits\n  };\n}\n\nfunction splitToPatterns(min, max, tok, options) {\n  let ranges = splitToRanges(min, max);\n  let tokens = [];\n  let start = min;\n  let prev;\n\n  for (let i = 0; i < ranges.length; i++) {\n    let max = ranges[i];\n    let obj = rangeToPattern(String(start), String(max), options);\n    let zeros = '';\n\n    if (!tok.isPadded && prev && prev.pattern === obj.pattern) {\n      if (prev.count.length > 1) {\n        prev.count.pop();\n      }\n\n      prev.count.push(obj.count[0]);\n      prev.string = prev.pattern + toQuantifier(prev.count);\n      start = max + 1;\n      continue;\n    }\n\n    if (tok.isPadded) {\n      zeros = padZeros(max, tok, options);\n    }\n\n    obj.string = zeros + obj.pattern + toQuantifier(obj.count);\n    tokens.push(obj);\n    start = max + 1;\n    prev = obj;\n  }\n\n  return tokens;\n}\n\nfunction filterPatterns(arr, comparison, prefix, intersection, options) {\n  let result = [];\n\n  for (let ele of arr) {\n    let {\n      string\n    } = ele; // only push if _both_ are negative...\n\n    if (!intersection && !contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    } // or _both_ are positive\n\n\n    if (intersection && contains(comparison, 'string', string)) {\n      result.push(prefix + string);\n    }\n  }\n\n  return result;\n}\n/**\n * Zip strings\n */\n\n\nfunction zip(a, b) {\n  let arr = [];\n\n  for (let i = 0; i < a.length; i++) arr.push([a[i], b[i]]);\n\n  return arr;\n}\n\nfunction compare(a, b) {\n  return a > b ? 1 : b > a ? -1 : 0;\n}\n\nfunction contains(arr, key, val) {\n  return arr.some(ele => ele[key] === val);\n}\n\nfunction countNines(min, len) {\n  return Number(String(min).slice(0, -len) + '9'.repeat(len));\n}\n\nfunction countZeros(integer, zeros) {\n  return integer - integer % Math.pow(10, zeros);\n}\n\nfunction toQuantifier(digits) {\n  let [start = 0, stop = ''] = digits;\n\n  if (stop || start > 1) {\n    return `{${start + (stop ? ',' + stop : '')}}`;\n  }\n\n  return '';\n}\n\nfunction toCharacterClass(a, b, options) {\n  return `[${a}${b - a === 1 ? '' : '-'}${b}]`;\n}\n\nfunction hasPadding(str) {\n  return /^-?(0+)\\d/.test(str);\n}\n\nfunction padZeros(value, tok, options) {\n  if (!tok.isPadded) {\n    return value;\n  }\n\n  let diff = Math.abs(tok.maxLen - String(value).length);\n  let relax = options.relaxZeros !== false;\n\n  switch (diff) {\n    case 0:\n      return '';\n\n    case 1:\n      return relax ? '0?' : '0';\n\n    case 2:\n      return relax ? '0{0,2}' : '00';\n\n    default:\n      {\n        return relax ? `0{0,${diff}}` : `0{${diff}}`;\n      }\n  }\n}\n/**\n * Cache\n */\n\n\ntoRegexRange.cache = {};\n\ntoRegexRange.clearCache = () => toRegexRange.cache = {};\n/**\n * Expose `toRegexRange`\n */\n\n\nvar toRegexRange_1 = toRegexRange;\n\nconst isObject$1 = val => val !== null && typeof val === 'object' && !Array.isArray(val);\n\nconst transform = toNumber => {\n  return value => toNumber === true ? Number(value) : String(value);\n};\n\nconst isValidValue = value => {\n  return typeof value === 'number' || typeof value === 'string' && value !== '';\n};\n\nconst isNumber$1 = num => Number.isInteger(+num);\n\nconst zeros = input => {\n  let value = `${input}`;\n  let index = -1;\n  if (value[0] === '-') value = value.slice(1);\n  if (value === '0') return false;\n\n  while (value[++index] === '0');\n\n  return index > 0;\n};\n\nconst stringify$1 = (start, end, options) => {\n  if (typeof start === 'string' || typeof end === 'string') {\n    return true;\n  }\n\n  return options.stringify === true;\n};\n\nconst pad = (input, maxLength, toNumber) => {\n  if (maxLength > 0) {\n    let dash = input[0] === '-' ? '-' : '';\n    if (dash) input = input.slice(1);\n    input = dash + input.padStart(dash ? maxLength - 1 : maxLength, '0');\n  }\n\n  if (toNumber === false) {\n    return String(input);\n  }\n\n  return input;\n};\n\nconst toMaxLen = (input, maxLength) => {\n  let negative = input[0] === '-' ? '-' : '';\n\n  if (negative) {\n    input = input.slice(1);\n    maxLength--;\n  }\n\n  while (input.length < maxLength) input = '0' + input;\n\n  return negative ? '-' + input : input;\n};\n\nconst toSequence = (parts, options) => {\n  parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);\n  let prefix = options.capture ? '' : '?:';\n  let positives = '';\n  let negatives = '';\n  let result;\n\n  if (parts.positives.length) {\n    positives = parts.positives.join('|');\n  }\n\n  if (parts.negatives.length) {\n    negatives = `-(${prefix}${parts.negatives.join('|')})`;\n  }\n\n  if (positives && negatives) {\n    result = `${positives}|${negatives}`;\n  } else {\n    result = positives || negatives;\n  }\n\n  if (options.wrap) {\n    return `(${prefix}${result})`;\n  }\n\n  return result;\n};\n\nconst toRange = (a, b, isNumbers, options) => {\n  if (isNumbers) {\n    return toRegexRange_1(a, b, {\n      wrap: false,\n      ...options\n    });\n  }\n\n  let start = String.fromCharCode(a);\n  if (a === b) return start;\n  let stop = String.fromCharCode(b);\n  return `[${start}-${stop}]`;\n};\n\nconst toRegex = (start, end, options) => {\n  if (Array.isArray(start)) {\n    let wrap = options.wrap === true;\n    let prefix = options.capture ? '' : '?:';\n    return wrap ? `(${prefix}${start.join('|')})` : start.join('|');\n  }\n\n  return toRegexRange_1(start, end, options);\n};\n\nconst rangeError = (...args) => {\n  return new RangeError('Invalid range arguments: ' + require$$0__default['default'].inspect(...args));\n};\n\nconst invalidRange = (start, end, options) => {\n  if (options.strictRanges === true) throw rangeError([start, end]);\n  return [];\n};\n\nconst invalidStep = (step, options) => {\n  if (options.strictRanges === true) {\n    throw new TypeError(`Expected step \"${step}\" to be a number`);\n  }\n\n  return [];\n};\n\nconst fillNumbers = (start, end, step = 1, options = {}) => {\n  let a = Number(start);\n  let b = Number(end);\n\n  if (!Number.isInteger(a) || !Number.isInteger(b)) {\n    if (options.strictRanges === true) throw rangeError([start, end]);\n    return [];\n  } // fix negative zero\n\n\n  if (a === 0) a = 0;\n  if (b === 0) b = 0;\n  let descending = a > b;\n  let startString = String(start);\n  let endString = String(end);\n  let stepString = String(step);\n  step = Math.max(Math.abs(step), 1);\n  let padded = zeros(startString) || zeros(endString) || zeros(stepString);\n  let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;\n  let toNumber = padded === false && stringify$1(start, end, options) === false;\n  let format = options.transform || transform(toNumber);\n\n  if (options.toRegex && step === 1) {\n    return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);\n  }\n\n  let parts = {\n    negatives: [],\n    positives: []\n  };\n\n  let push = num => parts[num < 0 ? 'negatives' : 'positives'].push(Math.abs(num));\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    if (options.toRegex === true && step > 1) {\n      push(a);\n    } else {\n      range.push(pad(format(a, index), maxLen, toNumber));\n    }\n\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return step > 1 ? toSequence(parts, options) : toRegex(range, null, {\n      wrap: false,\n      ...options\n    });\n  }\n\n  return range;\n};\n\nconst fillLetters = (start, end, step = 1, options = {}) => {\n  if (!isNumber$1(start) && start.length > 1 || !isNumber$1(end) && end.length > 1) {\n    return invalidRange(start, end, options);\n  }\n\n  let format = options.transform || (val => String.fromCharCode(val));\n\n  let a = `${start}`.charCodeAt(0);\n  let b = `${end}`.charCodeAt(0);\n  let descending = a > b;\n  let min = Math.min(a, b);\n  let max = Math.max(a, b);\n\n  if (options.toRegex && step === 1) {\n    return toRange(min, max, false, options);\n  }\n\n  let range = [];\n  let index = 0;\n\n  while (descending ? a >= b : a <= b) {\n    range.push(format(a, index));\n    a = descending ? a - step : a + step;\n    index++;\n  }\n\n  if (options.toRegex === true) {\n    return toRegex(range, null, {\n      wrap: false,\n      options\n    });\n  }\n\n  return range;\n};\n\nconst fill = (start, end, step, options = {}) => {\n  if (end == null && isValidValue(start)) {\n    return [start];\n  }\n\n  if (!isValidValue(start) || !isValidValue(end)) {\n    return invalidRange(start, end, options);\n  }\n\n  if (typeof step === 'function') {\n    return fill(start, end, 1, {\n      transform: step\n    });\n  }\n\n  if (isObject$1(step)) {\n    return fill(start, end, 0, step);\n  }\n\n  let opts = { ...options\n  };\n  if (opts.capture === true) opts.wrap = true;\n  step = step || opts.step || 1;\n\n  if (!isNumber$1(step)) {\n    if (step != null && !isObject$1(step)) return invalidStep(step, opts);\n    return fill(start, end, 1, step);\n  }\n\n  if (isNumber$1(start) && isNumber$1(end)) {\n    return fillNumbers(start, end, step, opts);\n  }\n\n  return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);\n};\n\nvar fillRange = fill;\n\nconst compile = (ast, options = {}) => {\n  let walk = (node, parent = {}) => {\n    let invalidBlock = utils$1.isInvalidBrace(parent);\n    let invalidNode = node.invalid === true && options.escapeInvalid === true;\n    let invalid = invalidBlock === true || invalidNode === true;\n    let prefix = options.escapeInvalid === true ? '\\\\' : '';\n    let output = '';\n\n    if (node.isOpen === true) {\n      return prefix + node.value;\n    }\n\n    if (node.isClose === true) {\n      return prefix + node.value;\n    }\n\n    if (node.type === 'open') {\n      return invalid ? prefix + node.value : '(';\n    }\n\n    if (node.type === 'close') {\n      return invalid ? prefix + node.value : ')';\n    }\n\n    if (node.type === 'comma') {\n      return node.prev.type === 'comma' ? '' : invalid ? node.value : '|';\n    }\n\n    if (node.value) {\n      return node.value;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils$1.reduce(node.nodes);\n      let range = fillRange(...args, { ...options,\n        wrap: false,\n        toRegex: true\n      });\n\n      if (range.length !== 0) {\n        return args.length > 1 && range.length > 1 ? `(${range})` : range;\n      }\n    }\n\n    if (node.nodes) {\n      for (let child of node.nodes) {\n        output += walk(child, node);\n      }\n    }\n\n    return output;\n  };\n\n  return walk(ast);\n};\n\nvar compile_1 = compile;\n\nconst append = (queue = '', stash = '', enclose = false) => {\n  let result = [];\n  queue = [].concat(queue);\n  stash = [].concat(stash);\n  if (!stash.length) return queue;\n\n  if (!queue.length) {\n    return enclose ? utils$1.flatten(stash).map(ele => `{${ele}}`) : stash;\n  }\n\n  for (let item of queue) {\n    if (Array.isArray(item)) {\n      for (let value of item) {\n        result.push(append(value, stash, enclose));\n      }\n    } else {\n      for (let ele of stash) {\n        if (enclose === true && typeof ele === 'string') ele = `{${ele}}`;\n        result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);\n      }\n    }\n  }\n\n  return utils$1.flatten(result);\n};\n\nconst expand = (ast, options = {}) => {\n  let rangeLimit = options.rangeLimit === void 0 ? 1000 : options.rangeLimit;\n\n  let walk = (node, parent = {}) => {\n    node.queue = [];\n    let p = parent;\n    let q = parent.queue;\n\n    while (p.type !== 'brace' && p.type !== 'root' && p.parent) {\n      p = p.parent;\n      q = p.queue;\n    }\n\n    if (node.invalid || node.dollar) {\n      q.push(append(q.pop(), stringify(node, options)));\n      return;\n    }\n\n    if (node.type === 'brace' && node.invalid !== true && node.nodes.length === 2) {\n      q.push(append(q.pop(), ['{}']));\n      return;\n    }\n\n    if (node.nodes && node.ranges > 0) {\n      let args = utils$1.reduce(node.nodes);\n\n      if (utils$1.exceedsLimit(...args, options.step, rangeLimit)) {\n        throw new RangeError('expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.');\n      }\n\n      let range = fillRange(...args, options);\n\n      if (range.length === 0) {\n        range = stringify(node, options);\n      }\n\n      q.push(append(q.pop(), range));\n      node.nodes = [];\n      return;\n    }\n\n    let enclose = utils$1.encloseBrace(node);\n    let queue = node.queue;\n    let block = node;\n\n    while (block.type !== 'brace' && block.type !== 'root' && block.parent) {\n      block = block.parent;\n      queue = block.queue;\n    }\n\n    for (let i = 0; i < node.nodes.length; i++) {\n      let child = node.nodes[i];\n\n      if (child.type === 'comma' && node.type === 'brace') {\n        if (i === 1) queue.push('');\n        queue.push('');\n        continue;\n      }\n\n      if (child.type === 'close') {\n        q.push(append(q.pop(), queue, enclose));\n        continue;\n      }\n\n      if (child.value && child.type !== 'open') {\n        queue.push(append(queue.pop(), child.value));\n        continue;\n      }\n\n      if (child.nodes) {\n        walk(child, node);\n      }\n    }\n\n    return queue;\n  };\n\n  return utils$1.flatten(walk(ast));\n};\n\nvar expand_1 = expand;\nvar constants$1 = {\n  MAX_LENGTH: 1024 * 64,\n  // Digits\n  CHAR_0: '0',\n\n  /* 0 */\n  CHAR_9: '9',\n\n  /* 9 */\n  // Alphabet chars.\n  CHAR_UPPERCASE_A: 'A',\n\n  /* A */\n  CHAR_LOWERCASE_A: 'a',\n\n  /* a */\n  CHAR_UPPERCASE_Z: 'Z',\n\n  /* Z */\n  CHAR_LOWERCASE_Z: 'z',\n\n  /* z */\n  CHAR_LEFT_PARENTHESES: '(',\n\n  /* ( */\n  CHAR_RIGHT_PARENTHESES: ')',\n\n  /* ) */\n  CHAR_ASTERISK: '*',\n\n  /* * */\n  // Non-alphabetic chars.\n  CHAR_AMPERSAND: '&',\n\n  /* & */\n  CHAR_AT: '@',\n\n  /* @ */\n  CHAR_BACKSLASH: '\\\\',\n\n  /* \\ */\n  CHAR_BACKTICK: '`',\n\n  /* ` */\n  CHAR_CARRIAGE_RETURN: '\\r',\n\n  /* \\r */\n  CHAR_CIRCUMFLEX_ACCENT: '^',\n\n  /* ^ */\n  CHAR_COLON: ':',\n\n  /* : */\n  CHAR_COMMA: ',',\n\n  /* , */\n  CHAR_DOLLAR: '$',\n\n  /* . */\n  CHAR_DOT: '.',\n\n  /* . */\n  CHAR_DOUBLE_QUOTE: '\"',\n\n  /* \" */\n  CHAR_EQUAL: '=',\n\n  /* = */\n  CHAR_EXCLAMATION_MARK: '!',\n\n  /* ! */\n  CHAR_FORM_FEED: '\\f',\n\n  /* \\f */\n  CHAR_FORWARD_SLASH: '/',\n\n  /* / */\n  CHAR_HASH: '#',\n\n  /* # */\n  CHAR_HYPHEN_MINUS: '-',\n\n  /* - */\n  CHAR_LEFT_ANGLE_BRACKET: '<',\n\n  /* < */\n  CHAR_LEFT_CURLY_BRACE: '{',\n\n  /* { */\n  CHAR_LEFT_SQUARE_BRACKET: '[',\n\n  /* [ */\n  CHAR_LINE_FEED: '\\n',\n\n  /* \\n */\n  CHAR_NO_BREAK_SPACE: '\\u00A0',\n\n  /* \\u00A0 */\n  CHAR_PERCENT: '%',\n\n  /* % */\n  CHAR_PLUS: '+',\n\n  /* + */\n  CHAR_QUESTION_MARK: '?',\n\n  /* ? */\n  CHAR_RIGHT_ANGLE_BRACKET: '>',\n\n  /* > */\n  CHAR_RIGHT_CURLY_BRACE: '}',\n\n  /* } */\n  CHAR_RIGHT_SQUARE_BRACKET: ']',\n\n  /* ] */\n  CHAR_SEMICOLON: ';',\n\n  /* ; */\n  CHAR_SINGLE_QUOTE: '\\'',\n\n  /* ' */\n  CHAR_SPACE: ' ',\n\n  /*   */\n  CHAR_TAB: '\\t',\n\n  /* \\t */\n  CHAR_UNDERSCORE: '_',\n\n  /* _ */\n  CHAR_VERTICAL_LINE: '|',\n\n  /* | */\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE: '\\uFEFF'\n  /* \\uFEFF */\n\n};\n/**\n * Constants\n */\n\nconst {\n  MAX_LENGTH: MAX_LENGTH$1,\n  CHAR_BACKSLASH,\n\n  /* \\ */\n  CHAR_BACKTICK,\n\n  /* ` */\n  CHAR_COMMA: CHAR_COMMA$1,\n\n  /* , */\n  CHAR_DOT: CHAR_DOT$1,\n\n  /* . */\n  CHAR_LEFT_PARENTHESES: CHAR_LEFT_PARENTHESES$1,\n\n  /* ( */\n  CHAR_RIGHT_PARENTHESES: CHAR_RIGHT_PARENTHESES$1,\n\n  /* ) */\n  CHAR_LEFT_CURLY_BRACE: CHAR_LEFT_CURLY_BRACE$1,\n\n  /* { */\n  CHAR_RIGHT_CURLY_BRACE: CHAR_RIGHT_CURLY_BRACE$1,\n\n  /* } */\n  CHAR_LEFT_SQUARE_BRACKET: CHAR_LEFT_SQUARE_BRACKET$1,\n\n  /* [ */\n  CHAR_RIGHT_SQUARE_BRACKET: CHAR_RIGHT_SQUARE_BRACKET$1,\n\n  /* ] */\n  CHAR_DOUBLE_QUOTE,\n\n  /* \" */\n  CHAR_SINGLE_QUOTE,\n\n  /* ' */\n  CHAR_NO_BREAK_SPACE,\n  CHAR_ZERO_WIDTH_NOBREAK_SPACE\n} = constants$1;\n/**\n * parse\n */\n\nconst parse$1 = (input, options = {}) => {\n  if (typeof input !== 'string') {\n    throw new TypeError('Expected a string');\n  }\n\n  let opts = options || {};\n  let max = typeof opts.maxLength === 'number' ? Math.min(MAX_LENGTH$1, opts.maxLength) : MAX_LENGTH$1;\n\n  if (input.length > max) {\n    throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);\n  }\n\n  let ast = {\n    type: 'root',\n    input,\n    nodes: []\n  };\n  let stack = [ast];\n  let block = ast;\n  let prev = ast;\n  let brackets = 0;\n  let length = input.length;\n  let index = 0;\n  let depth = 0;\n  let value;\n  /**\n   * Helpers\n   */\n\n  const advance = () => input[index++];\n\n  const push = node => {\n    if (node.type === 'text' && prev.type === 'dot') {\n      prev.type = 'text';\n    }\n\n    if (prev && prev.type === 'text' && node.type === 'text') {\n      prev.value += node.value;\n      return;\n    }\n\n    block.nodes.push(node);\n    node.parent = block;\n    node.prev = prev;\n    prev = node;\n    return node;\n  };\n\n  push({\n    type: 'bos'\n  });\n\n  while (index < length) {\n    block = stack[stack.length - 1];\n    value = advance();\n    /**\n     * Invalid chars\n     */\n\n    if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {\n      continue;\n    }\n    /**\n     * Escaped chars\n     */\n\n\n    if (value === CHAR_BACKSLASH) {\n      push({\n        type: 'text',\n        value: (options.keepEscaping ? value : '') + advance()\n      });\n      continue;\n    }\n    /**\n     * Right square bracket (literal): ']'\n     */\n\n\n    if (value === CHAR_RIGHT_SQUARE_BRACKET$1) {\n      push({\n        type: 'text',\n        value: '\\\\' + value\n      });\n      continue;\n    }\n    /**\n     * Left square bracket: '['\n     */\n\n\n    if (value === CHAR_LEFT_SQUARE_BRACKET$1) {\n      brackets++;\n      let next;\n\n      while (index < length && (next = advance())) {\n        value += next;\n\n        if (next === CHAR_LEFT_SQUARE_BRACKET$1) {\n          brackets++;\n          continue;\n        }\n\n        if (next === CHAR_BACKSLASH) {\n          value += advance();\n          continue;\n        }\n\n        if (next === CHAR_RIGHT_SQUARE_BRACKET$1) {\n          brackets--;\n\n          if (brackets === 0) {\n            break;\n          }\n        }\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Parentheses\n     */\n\n\n    if (value === CHAR_LEFT_PARENTHESES$1) {\n      block = push({\n        type: 'paren',\n        nodes: []\n      });\n      stack.push(block);\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n\n    if (value === CHAR_RIGHT_PARENTHESES$1) {\n      if (block.type !== 'paren') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      block = stack.pop();\n      push({\n        type: 'text',\n        value\n      });\n      block = stack[stack.length - 1];\n      continue;\n    }\n    /**\n     * Quotes: '|\"|`\n     */\n\n\n    if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {\n      let open = value;\n      let next;\n\n      if (options.keepQuotes !== true) {\n        value = '';\n      }\n\n      while (index < length && (next = advance())) {\n        if (next === CHAR_BACKSLASH) {\n          value += next + advance();\n          continue;\n        }\n\n        if (next === open) {\n          if (options.keepQuotes === true) value += next;\n          break;\n        }\n\n        value += next;\n      }\n\n      push({\n        type: 'text',\n        value\n      });\n      continue;\n    }\n    /**\n     * Left curly brace: '{'\n     */\n\n\n    if (value === CHAR_LEFT_CURLY_BRACE$1) {\n      depth++;\n      let dollar = prev.value && prev.value.slice(-1) === '$' || block.dollar === true;\n      let brace = {\n        type: 'brace',\n        open: true,\n        close: false,\n        dollar,\n        depth,\n        commas: 0,\n        ranges: 0,\n        nodes: []\n      };\n      block = push(brace);\n      stack.push(block);\n      push({\n        type: 'open',\n        value\n      });\n      continue;\n    }\n    /**\n     * Right curly brace: '}'\n     */\n\n\n    if (value === CHAR_RIGHT_CURLY_BRACE$1) {\n      if (block.type !== 'brace') {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      let type = 'close';\n      block = stack.pop();\n      block.close = true;\n      push({\n        type,\n        value\n      });\n      depth--;\n      block = stack[stack.length - 1];\n      continue;\n    }\n    /**\n     * Comma: ','\n     */\n\n\n    if (value === CHAR_COMMA$1 && depth > 0) {\n      if (block.ranges > 0) {\n        block.ranges = 0;\n        let open = block.nodes.shift();\n        block.nodes = [open, {\n          type: 'text',\n          value: stringify(block)\n        }];\n      }\n\n      push({\n        type: 'comma',\n        value\n      });\n      block.commas++;\n      continue;\n    }\n    /**\n     * Dot: '.'\n     */\n\n\n    if (value === CHAR_DOT$1 && depth > 0 && block.commas === 0) {\n      let siblings = block.nodes;\n\n      if (depth === 0 || siblings.length === 0) {\n        push({\n          type: 'text',\n          value\n        });\n        continue;\n      }\n\n      if (prev.type === 'dot') {\n        block.range = [];\n        prev.value += value;\n        prev.type = 'range';\n\n        if (block.nodes.length !== 3 && block.nodes.length !== 5) {\n          block.invalid = true;\n          block.ranges = 0;\n          prev.type = 'text';\n          continue;\n        }\n\n        block.ranges++;\n        block.args = [];\n        continue;\n      }\n\n      if (prev.type === 'range') {\n        siblings.pop();\n        let before = siblings[siblings.length - 1];\n        before.value += prev.value + value;\n        prev = before;\n        block.ranges--;\n        continue;\n      }\n\n      push({\n        type: 'dot',\n        value\n      });\n      continue;\n    }\n    /**\n     * Text\n     */\n\n\n    push({\n      type: 'text',\n      value\n    });\n  } // Mark imbalanced braces and brackets as invalid\n\n\n  do {\n    block = stack.pop();\n\n    if (block.type !== 'root') {\n      block.nodes.forEach(node => {\n        if (!node.nodes) {\n          if (node.type === 'open') node.isOpen = true;\n          if (node.type === 'close') node.isClose = true;\n          if (!node.nodes) node.type = 'text';\n          node.invalid = true;\n        }\n      }); // get the location of the block on parent.nodes (block's siblings)\n\n      let parent = stack[stack.length - 1];\n      let index = parent.nodes.indexOf(block); // replace the (invalid) block with it's nodes\n\n      parent.nodes.splice(index, 1, ...block.nodes);\n    }\n  } while (stack.length > 0);\n\n  push({\n    type: 'eos'\n  });\n  return ast;\n};\n\nvar parse_1$1 = parse$1;\n/**\n * Expand the given pattern or create a regex-compatible string.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces('{a,b,c}', { compile: true })); //=> ['(a|b|c)']\n * console.log(braces('{a,b,c}')); //=> ['a', 'b', 'c']\n * ```\n * @param {String} `str`\n * @param {Object} `options`\n * @return {String}\n * @api public\n */\n\nconst braces = (input, options = {}) => {\n  let output = [];\n\n  if (Array.isArray(input)) {\n    for (let pattern of input) {\n      let result = braces.create(pattern, options);\n\n      if (Array.isArray(result)) {\n        output.push(...result);\n      } else {\n        output.push(result);\n      }\n    }\n  } else {\n    output = [].concat(braces.create(input, options));\n  }\n\n  if (options && options.expand === true && options.nodupes === true) {\n    output = [...new Set(output)];\n  }\n\n  return output;\n};\n/**\n * Parse the given `str` with the given `options`.\n *\n * ```js\n * // braces.parse(pattern, [, options]);\n * const ast = braces.parse('a/{b,c}/d');\n * console.log(ast);\n * ```\n * @param {String} pattern Brace pattern to parse\n * @param {Object} options\n * @return {Object} Returns an AST\n * @api public\n */\n\n\nbraces.parse = (input, options = {}) => parse_1$1(input, options);\n/**\n * Creates a braces string from an AST, or an AST node.\n *\n * ```js\n * const braces = require('braces');\n * let ast = braces.parse('foo/{a,b}/bar');\n * console.log(stringify(ast.nodes[2])); //=> '{a,b}'\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces.stringify = (input, options = {}) => {\n  if (typeof input === 'string') {\n    return stringify(braces.parse(input, options), options);\n  }\n\n  return stringify(input, options);\n};\n/**\n * Compiles a brace pattern into a regex-compatible, optimized string.\n * This method is called by the main [braces](#braces) function by default.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.compile('a/{b,c}/d'));\n * //=> ['a/(b|c)/d']\n * ```\n * @param {String} `input` Brace pattern or AST.\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces.compile = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  return compile_1(input, options);\n};\n/**\n * Expands a brace pattern into an array. This method is called by the\n * main [braces](#braces) function when `options.expand` is true. Before\n * using this method it's recommended that you read the [performance notes](#performance))\n * and advantages of using [.compile](#compile) instead.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.expand('a/{b,c}/d'));\n * //=> ['a/b/d', 'a/c/d'];\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces.expand = (input, options = {}) => {\n  if (typeof input === 'string') {\n    input = braces.parse(input, options);\n  }\n\n  let result = expand_1(input, options); // filter out empty strings if specified\n\n  if (options.noempty === true) {\n    result = result.filter(Boolean);\n  } // filter out duplicates if specified\n\n\n  if (options.nodupes === true) {\n    result = [...new Set(result)];\n  }\n\n  return result;\n};\n/**\n * Processes a brace pattern and returns either an expanded array\n * (if `options.expand` is true), a highly optimized regex-compatible string.\n * This method is called by the main [braces](#braces) function.\n *\n * ```js\n * const braces = require('braces');\n * console.log(braces.create('user-{200..300}/project-{a,b,c}-{1..10}'))\n * //=> 'user-(20[0-9]|2[1-9][0-9]|300)/project-(a|b|c)-([1-9]|10)'\n * ```\n * @param {String} `pattern` Brace pattern\n * @param {Object} `options`\n * @return {Array} Returns an array of expanded values.\n * @api public\n */\n\n\nbraces.create = (input, options = {}) => {\n  if (input === '' || input.length < 3) {\n    return [input];\n  }\n\n  return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);\n};\n/**\n * Expose \"braces\"\n */\n\n\nvar braces_1 = braces;\nvar require$$0 = [\"3dm\", \"3ds\", \"3g2\", \"3gp\", \"7z\", \"a\", \"aac\", \"adp\", \"ai\", \"aif\", \"aiff\", \"alz\", \"ape\", \"apk\", \"appimage\", \"ar\", \"arj\", \"asf\", \"au\", \"avi\", \"bak\", \"baml\", \"bh\", \"bin\", \"bk\", \"bmp\", \"btif\", \"bz2\", \"bzip2\", \"cab\", \"caf\", \"cgm\", \"class\", \"cmx\", \"cpio\", \"cr2\", \"cur\", \"dat\", \"dcm\", \"deb\", \"dex\", \"djvu\", \"dll\", \"dmg\", \"dng\", \"doc\", \"docm\", \"docx\", \"dot\", \"dotm\", \"dra\", \"DS_Store\", \"dsk\", \"dts\", \"dtshd\", \"dvb\", \"dwg\", \"dxf\", \"ecelp4800\", \"ecelp7470\", \"ecelp9600\", \"egg\", \"eol\", \"eot\", \"epub\", \"exe\", \"f4v\", \"fbs\", \"fh\", \"fla\", \"flac\", \"flatpak\", \"fli\", \"flv\", \"fpx\", \"fst\", \"fvt\", \"g3\", \"gh\", \"gif\", \"graffle\", \"gz\", \"gzip\", \"h261\", \"h263\", \"h264\", \"icns\", \"ico\", \"ief\", \"img\", \"ipa\", \"iso\", \"jar\", \"jpeg\", \"jpg\", \"jpgv\", \"jpm\", \"jxr\", \"key\", \"ktx\", \"lha\", \"lib\", \"lvp\", \"lz\", \"lzh\", \"lzma\", \"lzo\", \"m3u\", \"m4a\", \"m4v\", \"mar\", \"mdi\", \"mht\", \"mid\", \"midi\", \"mj2\", \"mka\", \"mkv\", \"mmr\", \"mng\", \"mobi\", \"mov\", \"movie\", \"mp3\", \"mp4\", \"mp4a\", \"mpeg\", \"mpg\", \"mpga\", \"mxu\", \"nef\", \"npx\", \"numbers\", \"nupkg\", \"o\", \"oga\", \"ogg\", \"ogv\", \"otf\", \"pages\", \"pbm\", \"pcx\", \"pdb\", \"pdf\", \"pea\", \"pgm\", \"pic\", \"png\", \"pnm\", \"pot\", \"potm\", \"potx\", \"ppa\", \"ppam\", \"ppm\", \"pps\", \"ppsm\", \"ppsx\", \"ppt\", \"pptm\", \"pptx\", \"psd\", \"pya\", \"pyc\", \"pyo\", \"pyv\", \"qt\", \"rar\", \"ras\", \"raw\", \"resources\", \"rgb\", \"rip\", \"rlc\", \"rmf\", \"rmvb\", \"rpm\", \"rtf\", \"rz\", \"s3m\", \"s7z\", \"scpt\", \"sgi\", \"shar\", \"snap\", \"sil\", \"sketch\", \"slk\", \"smv\", \"snk\", \"so\", \"stl\", \"suo\", \"sub\", \"swf\", \"tar\", \"tbz\", \"tbz2\", \"tga\", \"tgz\", \"thmx\", \"tif\", \"tiff\", \"tlz\", \"ttc\", \"ttf\", \"txz\", \"udf\", \"uvh\", \"uvi\", \"uvm\", \"uvp\", \"uvs\", \"uvu\", \"viv\", \"vob\", \"war\", \"wav\", \"wax\", \"wbmp\", \"wdp\", \"weba\", \"webm\", \"webp\", \"whl\", \"wim\", \"wm\", \"wma\", \"wmv\", \"wmx\", \"woff\", \"woff2\", \"wrm\", \"wvx\", \"xbm\", \"xif\", \"xla\", \"xlam\", \"xls\", \"xlsb\", \"xlsm\", \"xlsx\", \"xlt\", \"xltm\", \"xltx\", \"xm\", \"xmind\", \"xpi\", \"xpm\", \"xwd\", \"xz\", \"z\", \"zip\", \"zipx\"];\nvar binaryExtensions = require$$0;\nconst extensions = new Set(binaryExtensions);\n\nvar isBinaryPath = filePath => extensions.has(sysPath__default['default'].extname(filePath).slice(1).toLowerCase());\n\nvar constants$2 = createCommonjsModule(function (module, exports) {\n  const {\n    sep\n  } = sysPath__default['default'];\n  const {\n    platform\n  } = process;\n  exports.EV_ALL = 'all';\n  exports.EV_READY = 'ready';\n  exports.EV_ADD = 'add';\n  exports.EV_CHANGE = 'change';\n  exports.EV_ADD_DIR = 'addDir';\n  exports.EV_UNLINK = 'unlink';\n  exports.EV_UNLINK_DIR = 'unlinkDir';\n  exports.EV_RAW = 'raw';\n  exports.EV_ERROR = 'error';\n  exports.STR_DATA = 'data';\n  exports.STR_END = 'end';\n  exports.STR_CLOSE = 'close';\n  exports.FSEVENT_CREATED = 'created';\n  exports.FSEVENT_MODIFIED = 'modified';\n  exports.FSEVENT_DELETED = 'deleted';\n  exports.FSEVENT_MOVED = 'moved';\n  exports.FSEVENT_CLONED = 'cloned';\n  exports.FSEVENT_UNKNOWN = 'unknown';\n  exports.FSEVENT_TYPE_FILE = 'file';\n  exports.FSEVENT_TYPE_DIRECTORY = 'directory';\n  exports.FSEVENT_TYPE_SYMLINK = 'symlink';\n  exports.KEY_LISTENERS = 'listeners';\n  exports.KEY_ERR = 'errHandlers';\n  exports.KEY_RAW = 'rawEmitters';\n  exports.HANDLER_KEYS = [exports.KEY_LISTENERS, exports.KEY_ERR, exports.KEY_RAW];\n  exports.DOT_SLASH = `.${sep}`;\n  exports.BACK_SLASH_RE = /\\\\/g;\n  exports.DOUBLE_SLASH_RE = /\\/\\//;\n  exports.SLASH_OR_BACK_SLASH_RE = /[/\\\\]/;\n  exports.DOT_RE = /\\..*\\.(sw[px])$|~$|\\.subl.*\\.tmp/;\n  exports.REPLACER_RE = /^\\.[/\\\\]/;\n  exports.SLASH = '/';\n  exports.SLASH_SLASH = '//';\n  exports.BRACE_START = '{';\n  exports.BANG = '!';\n  exports.ONE_DOT = '.';\n  exports.TWO_DOTS = '..';\n  exports.STAR = '*';\n  exports.GLOBSTAR = '**';\n  exports.ROOT_GLOBSTAR = '/**/*';\n  exports.SLASH_GLOBSTAR = '/**';\n  exports.DIR_SUFFIX = 'Dir';\n  exports.ANYMATCH_OPTS = {\n    dot: true\n  };\n  exports.STRING_TYPE = 'string';\n  exports.FUNCTION_TYPE = 'function';\n  exports.EMPTY_STR = '';\n\n  exports.EMPTY_FN = () => {};\n\n  exports.IDENTITY_FN = val => val;\n\n  exports.isWindows = platform === 'win32';\n  exports.isMacos = platform === 'darwin';\n  exports.isLinux = platform === 'linux';\n});\nconst {\n  promisify: promisify$1\n} = require$$0__default['default'];\nconst {\n  isWindows,\n  isLinux,\n  EMPTY_FN,\n  EMPTY_STR,\n  KEY_LISTENERS,\n  KEY_ERR,\n  KEY_RAW,\n  HANDLER_KEYS,\n  EV_CHANGE,\n  EV_ADD,\n  EV_ADD_DIR,\n  EV_ERROR,\n  STR_DATA,\n  STR_END,\n  BRACE_START,\n  STAR: STAR$1\n} = constants$2;\nconst THROTTLE_MODE_WATCH = 'watch';\nconst open = promisify$1(fs__default['default'].open);\nconst stat$1 = promisify$1(fs__default['default'].stat);\nconst lstat$1 = promisify$1(fs__default['default'].lstat);\nconst close = promisify$1(fs__default['default'].close);\nconst fsrealpath = promisify$1(fs__default['default'].realpath);\nconst statMethods = {\n  lstat: lstat$1,\n  stat: stat$1\n}; // TODO: emit errors properly. Example: EMFILE on Macos.\n\nconst foreach = (val, fn) => {\n  if (val instanceof Set) {\n    val.forEach(fn);\n  } else {\n    fn(val);\n  }\n};\n\nconst addAndConvert = (main, prop, item) => {\n  let container = main[prop];\n\n  if (!(container instanceof Set)) {\n    main[prop] = container = new Set([container]);\n  }\n\n  container.add(item);\n};\n\nconst clearItem = cont => key => {\n  const set = cont[key];\n\n  if (set instanceof Set) {\n    set.clear();\n  } else {\n    delete cont[key];\n  }\n};\n\nconst delFromSet = (main, prop, item) => {\n  const container = main[prop];\n\n  if (container instanceof Set) {\n    container.delete(item);\n  } else if (container === item) {\n    delete main[prop];\n  }\n};\n\nconst isEmptySet = val => val instanceof Set ? val.size === 0 : !val;\n/**\n * @typedef {String} Path\n */\n// fs_watch helpers\n// object to hold per-process fs_watch instances\n// (may be shared across chokidar FSWatcher instances)\n\n/**\n * @typedef {Object} FsWatchContainer\n * @property {Set} listeners\n * @property {Set} errHandlers\n * @property {Set} rawEmitters\n * @property {fs.FSWatcher=} watcher\n * @property {Boolean=} watcherUnusable\n */\n\n/**\n * @type {Map<String,FsWatchContainer>}\n */\n\n\nconst FsWatchInstances = new Map();\n/**\n * Instantiates the fs_watch interface\n * @param {String} path to be watched\n * @param {Object} options to be passed to fs_watch\n * @param {Function} listener main event handler\n * @param {Function} errHandler emits info about errors\n * @param {Function} emitRaw emits raw event data\n * @returns {fs.FSWatcher} new fsevents instance\n */\n\nfunction createFsWatchInstance(path, options, listener, errHandler, emitRaw) {\n  const handleEvent = (rawEvent, evPath) => {\n    listener(path);\n    emitRaw(rawEvent, evPath, {\n      watchedPath: path\n    }); // emit based on events occurring for files from a directory's watcher in\n    // case the file's watcher misses it (and rely on throttling to de-dupe)\n\n    if (evPath && path !== evPath) {\n      fsWatchBroadcast(sysPath__default['default'].resolve(path, evPath), KEY_LISTENERS, sysPath__default['default'].join(path, evPath));\n    }\n  };\n\n  try {\n    return fs__default['default'].watch(path, options, handleEvent);\n  } catch (error) {\n    errHandler(error);\n  }\n}\n/**\n * Helper for passing fs_watch event data to a collection of listeners\n * @param {Path} fullPath absolute path bound to fs_watch instance\n * @param {String} type listener type\n * @param {*=} val1 arguments to be passed to listeners\n * @param {*=} val2\n * @param {*=} val3\n */\n\n\nconst fsWatchBroadcast = (fullPath, type, val1, val2, val3) => {\n  const cont = FsWatchInstances.get(fullPath);\n  if (!cont) return;\n  foreach(cont[type], listener => {\n    listener(val1, val2, val3);\n  });\n};\n/**\n * Instantiates the fs_watch interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path\n * @param {String} fullPath absolute path\n * @param {Object} options to be passed to fs_watch\n * @param {Object} handlers container for event listener functions\n */\n\n\nconst setFsWatchListener = (path, fullPath, options, handlers) => {\n  const {\n    listener,\n    errHandler,\n    rawEmitter\n  } = handlers;\n  let cont = FsWatchInstances.get(fullPath);\n  /** @type {fs.FSWatcher=} */\n\n  let watcher;\n\n  if (!options.persistent) {\n    watcher = createFsWatchInstance(path, options, listener, errHandler, rawEmitter);\n    return watcher.close.bind(watcher);\n  }\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_ERR, errHandler);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    watcher = createFsWatchInstance(path, options, fsWatchBroadcast.bind(null, fullPath, KEY_LISTENERS), errHandler, // no need to use broadcast here\n    fsWatchBroadcast.bind(null, fullPath, KEY_RAW));\n    if (!watcher) return;\n    watcher.on(EV_ERROR, async error => {\n      const broadcastErr = fsWatchBroadcast.bind(null, fullPath, KEY_ERR);\n      cont.watcherUnusable = true; // documented since Node 10.4.1\n      // Workaround for https://github.com/joyent/node/issues/4337\n\n      if (isWindows && error.code === 'EPERM') {\n        try {\n          const fd = await open(path, 'r');\n          await close(fd);\n          broadcastErr(error);\n        } catch (err) {}\n      } else {\n        broadcastErr(error);\n      }\n    });\n    cont = {\n      listeners: listener,\n      errHandlers: errHandler,\n      rawEmitters: rawEmitter,\n      watcher\n    };\n    FsWatchInstances.set(fullPath, cont);\n  } // const index = cont.listeners.indexOf(listener);\n  // removes this instance's listeners and closes the underlying fs_watch\n  // instance if there are no more listeners left\n\n\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_ERR, errHandler);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n\n    if (isEmptySet(cont.listeners)) {\n      // Check to protect against issue gh-730.\n      // if (cont.watcherUnusable) {\n      cont.watcher.close(); // }\n\n      FsWatchInstances.delete(fullPath);\n      HANDLER_KEYS.forEach(clearItem(cont));\n      cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n}; // fs_watchFile helpers\n// object to hold per-process fs_watchFile instances\n// (may be shared across chokidar FSWatcher instances)\n\n\nconst FsWatchFileInstances = new Map();\n/**\n * Instantiates the fs_watchFile interface or binds listeners\n * to an existing one covering the same file system entry\n * @param {String} path to be watched\n * @param {String} fullPath absolute path\n * @param {Object} options options to be passed to fs_watchFile\n * @param {Object} handlers container for event listener functions\n * @returns {Function} closer\n */\n\nconst setFsWatchFileListener = (path, fullPath, options, handlers) => {\n  const {\n    listener,\n    rawEmitter\n  } = handlers;\n  let cont = FsWatchFileInstances.get(fullPath);\n  /* eslint-disable no-unused-vars, prefer-destructuring */\n\n  let listeners = new Set();\n  let rawEmitters = new Set();\n  const copts = cont && cont.options;\n\n  if (copts && (copts.persistent < options.persistent || copts.interval > options.interval)) {\n    // \"Upgrade\" the watcher to persistence or a quicker interval.\n    // This creates some unlikely edge case issues if the user mixes\n    // settings in a very weird way, but solving for those cases\n    // doesn't seem worthwhile for the added complexity.\n    listeners = cont.listeners;\n    rawEmitters = cont.rawEmitters;\n    fs__default['default'].unwatchFile(fullPath);\n    cont = undefined;\n  }\n  /* eslint-enable no-unused-vars, prefer-destructuring */\n\n\n  if (cont) {\n    addAndConvert(cont, KEY_LISTENERS, listener);\n    addAndConvert(cont, KEY_RAW, rawEmitter);\n  } else {\n    // TODO\n    // listeners.add(listener);\n    // rawEmitters.add(rawEmitter);\n    cont = {\n      listeners: listener,\n      rawEmitters: rawEmitter,\n      options,\n      watcher: fs__default['default'].watchFile(fullPath, options, (curr, prev) => {\n        foreach(cont.rawEmitters, rawEmitter => {\n          rawEmitter(EV_CHANGE, fullPath, {\n            curr,\n            prev\n          });\n        });\n        const currmtime = curr.mtimeMs;\n\n        if (curr.size !== prev.size || currmtime > prev.mtimeMs || currmtime === 0) {\n          foreach(cont.listeners, listener => listener(path, curr));\n        }\n      })\n    };\n    FsWatchFileInstances.set(fullPath, cont);\n  } // const index = cont.listeners.indexOf(listener);\n  // Removes this instance's listeners and closes the underlying fs_watchFile\n  // instance if there are no more listeners left.\n\n\n  return () => {\n    delFromSet(cont, KEY_LISTENERS, listener);\n    delFromSet(cont, KEY_RAW, rawEmitter);\n\n    if (isEmptySet(cont.listeners)) {\n      FsWatchFileInstances.delete(fullPath);\n      fs__default['default'].unwatchFile(fullPath);\n      cont.options = cont.watcher = undefined;\n      Object.freeze(cont);\n    }\n  };\n};\n/**\n * @mixin\n */\n\n\nclass NodeFsHandler {\n  /**\n   * @param {import(\"../index\").FSWatcher} fsW\n   */\n  constructor(fsW) {\n    this.fsw = fsW;\n\n    this._boundHandleError = error => fsW._handleError(error);\n  }\n  /**\n   * Watch file for changes with fs_watchFile or fs_watch.\n   * @param {String} path to file or dir\n   * @param {Function} listener on fs change\n   * @returns {Function} closer for the watcher instance\n   */\n\n\n  _watchWithNodeFs(path, listener) {\n    const opts = this.fsw.options;\n    const directory = sysPath__default['default'].dirname(path);\n    const basename = sysPath__default['default'].basename(path);\n\n    const parent = this.fsw._getWatchedDir(directory);\n\n    parent.add(basename);\n    const absolutePath = sysPath__default['default'].resolve(path);\n    const options = {\n      persistent: opts.persistent\n    };\n    if (!listener) listener = EMPTY_FN;\n    let closer;\n\n    if (opts.usePolling) {\n      options.interval = opts.enableBinaryInterval && isBinaryPath(basename) ? opts.binaryInterval : opts.interval;\n      closer = setFsWatchFileListener(path, absolutePath, options, {\n        listener,\n        rawEmitter: this.fsw._emitRaw\n      });\n    } else {\n      closer = setFsWatchListener(path, absolutePath, options, {\n        listener,\n        errHandler: this._boundHandleError,\n        rawEmitter: this.fsw._emitRaw\n      });\n    }\n\n    return closer;\n  }\n  /**\n   * Watch a file and emit add event if warranted.\n   * @param {Path} file Path\n   * @param {fs.Stats} stats result of fs_stat\n   * @param {Boolean} initialAdd was the file added at watch instantiation?\n   * @returns {Function} closer for the watcher instance\n   */\n\n\n  _handleFile(file, stats, initialAdd) {\n    if (this.fsw.closed) {\n      return;\n    }\n\n    const dirname = sysPath__default['default'].dirname(file);\n    const basename = sysPath__default['default'].basename(file);\n\n    const parent = this.fsw._getWatchedDir(dirname); // stats is always present\n\n\n    let prevStats = stats; // if the file is already being watched, do nothing\n\n    if (parent.has(basename)) return;\n\n    const listener = async (path, newStats) => {\n      if (!this.fsw._throttle(THROTTLE_MODE_WATCH, file, 5)) return;\n\n      if (!newStats || newStats.mtimeMs === 0) {\n        try {\n          const newStats = await stat$1(file);\n          if (this.fsw.closed) return; // Check that change event was not fired because of changed only accessTime.\n\n          const at = newStats.atimeMs;\n          const mt = newStats.mtimeMs;\n\n          if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n            this.fsw._emit(EV_CHANGE, file, newStats);\n          }\n\n          if (isLinux && prevStats.ino !== newStats.ino) {\n            this.fsw._closeFile(path);\n\n            prevStats = newStats;\n\n            this.fsw._addPathCloser(path, this._watchWithNodeFs(file, listener));\n          } else {\n            prevStats = newStats;\n          }\n        } catch (error) {\n          // Fix issues where mtime is null but file is still present\n          this.fsw._remove(dirname, basename);\n        } // add is about to be emitted if file not already tracked in parent\n\n      } else if (parent.has(basename)) {\n        // Check that change event was not fired because of changed only accessTime.\n        const at = newStats.atimeMs;\n        const mt = newStats.mtimeMs;\n\n        if (!at || at <= mt || mt !== prevStats.mtimeMs) {\n          this.fsw._emit(EV_CHANGE, file, newStats);\n        }\n\n        prevStats = newStats;\n      }\n    }; // kick off the watcher\n\n\n    const closer = this._watchWithNodeFs(file, listener); // emit an add event if we're supposed to\n\n\n    if (!(initialAdd && this.fsw.options.ignoreInitial) && this.fsw._isntIgnored(file)) {\n      if (!this.fsw._throttle(EV_ADD, file, 0)) return;\n\n      this.fsw._emit(EV_ADD, file, stats);\n    }\n\n    return closer;\n  }\n  /**\n   * Handle symlinks encountered while reading a dir.\n   * @param {Object} entry returned by readdirp\n   * @param {String} directory path of dir being read\n   * @param {String} path of this item\n   * @param {String} item basename of this item\n   * @returns {Promise<Boolean>} true if no more processing is needed for this entry.\n   */\n\n\n  async _handleSymlink(entry, directory, path, item) {\n    if (this.fsw.closed) {\n      return;\n    }\n\n    const full = entry.fullPath;\n\n    const dir = this.fsw._getWatchedDir(directory);\n\n    if (!this.fsw.options.followSymlinks) {\n      // watch symlink directly (don't follow) and detect changes\n      this.fsw._incrReadyCount();\n\n      const linkPath = await fsrealpath(path);\n      if (this.fsw.closed) return;\n\n      if (dir.has(item)) {\n        if (this.fsw._symlinkPaths.get(full) !== linkPath) {\n          this.fsw._symlinkPaths.set(full, linkPath);\n\n          this.fsw._emit(EV_CHANGE, path, entry.stats);\n        }\n      } else {\n        dir.add(item);\n\n        this.fsw._symlinkPaths.set(full, linkPath);\n\n        this.fsw._emit(EV_ADD, path, entry.stats);\n      }\n\n      this.fsw._emitReady();\n\n      return true;\n    } // don't follow the same symlink more than once\n\n\n    if (this.fsw._symlinkPaths.has(full)) {\n      return true;\n    }\n\n    this.fsw._symlinkPaths.set(full, true);\n  }\n\n  _handleRead(directory, initialAdd, wh, target, dir, depth, throttler) {\n    // Normalize the directory name on Windows\n    directory = sysPath__default['default'].join(directory, EMPTY_STR);\n\n    if (!wh.hasGlob) {\n      throttler = this.fsw._throttle('readdir', directory, 1000);\n      if (!throttler) return;\n    }\n\n    const previous = this.fsw._getWatchedDir(wh.path);\n\n    const current = new Set();\n\n    let stream = this.fsw._readdirp(directory, {\n      fileFilter: entry => wh.filterPath(entry),\n      directoryFilter: entry => wh.filterDir(entry),\n      depth: 0\n    }).on(STR_DATA, async entry => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n\n      const item = entry.path;\n      let path = sysPath__default['default'].join(directory, item);\n      current.add(item);\n\n      if (entry.stats.isSymbolicLink() && (await this._handleSymlink(entry, directory, path, item))) {\n        return;\n      }\n\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      } // Files that present in current directory snapshot\n      // but absent in previous are added to watch list and\n      // emit `add` event.\n\n\n      if (item === target || !target && !previous.has(item)) {\n        this.fsw._incrReadyCount(); // ensure relativeness of path is preserved in case of watcher reuse\n\n\n        path = sysPath__default['default'].join(dir, sysPath__default['default'].relative(dir, path));\n\n        this._addToNodeFs(path, initialAdd, wh, depth + 1);\n      }\n    }).on(EV_ERROR, this._boundHandleError);\n\n    return new Promise(resolve => stream.once(STR_END, () => {\n      if (this.fsw.closed) {\n        stream = undefined;\n        return;\n      }\n\n      const wasThrottled = throttler ? throttler.clear() : false;\n      resolve(); // Files that absent in current directory snapshot\n      // but present in previous emit `remove` event\n      // and are removed from @watched[directory].\n\n      previous.getChildren().filter(item => {\n        return item !== directory && !current.has(item) && ( // in case of intersecting globs;\n        // a path may have been filtered out of this readdir, but\n        // shouldn't be removed because it matches a different glob\n        !wh.hasGlob || wh.filterPath({\n          fullPath: sysPath__default['default'].resolve(directory, item)\n        }));\n      }).forEach(item => {\n        this.fsw._remove(directory, item);\n      });\n      stream = undefined; // one more time for any missed in case changes came in extremely quickly\n\n      if (wasThrottled) this._handleRead(directory, false, wh, target, dir, depth, throttler);\n    }));\n  }\n  /**\n   * Read directory to add / remove files from `@watched` list and re-read it on change.\n   * @param {String} dir fs path\n   * @param {fs.Stats} stats\n   * @param {Boolean} initialAdd\n   * @param {Number} depth relative to user-supplied path\n   * @param {String} target child path targeted for watch\n   * @param {Object} wh Common watch helpers for this path\n   * @param {String} realpath\n   * @returns {Promise<Function>} closer for the watcher instance.\n   */\n\n\n  async _handleDir(dir, stats, initialAdd, depth, target, wh, realpath) {\n    const parentDir = this.fsw._getWatchedDir(sysPath__default['default'].dirname(dir));\n\n    const tracked = parentDir.has(sysPath__default['default'].basename(dir));\n\n    if (!(initialAdd && this.fsw.options.ignoreInitial) && !target && !tracked) {\n      if (!wh.hasGlob || wh.globFilter(dir)) this.fsw._emit(EV_ADD_DIR, dir, stats);\n    } // ensure dir is tracked (harmless if redundant)\n\n\n    parentDir.add(sysPath__default['default'].basename(dir));\n\n    this.fsw._getWatchedDir(dir);\n\n    let throttler;\n    let closer;\n    const oDepth = this.fsw.options.depth;\n\n    if ((oDepth == null || depth <= oDepth) && !this.fsw._symlinkPaths.has(realpath)) {\n      if (!target) {\n        await this._handleRead(dir, initialAdd, wh, target, dir, depth, throttler);\n        if (this.fsw.closed) return;\n      }\n\n      closer = this._watchWithNodeFs(dir, (dirPath, stats) => {\n        // if current directory is removed, do nothing\n        if (stats && stats.mtimeMs === 0) return;\n\n        this._handleRead(dirPath, false, wh, target, dir, depth, throttler);\n      });\n    }\n\n    return closer;\n  }\n  /**\n   * Handle added file, directory, or glob pattern.\n   * Delegates call to _handleFile / _handleDir after checks.\n   * @param {String} path to file or ir\n   * @param {Boolean} initialAdd was the file added at watch instantiation?\n   * @param {Object} priorWh depth relative to user-supplied path\n   * @param {Number} depth Child path actually targeted for watch\n   * @param {String=} target Child path actually targeted for watch\n   * @returns {Promise}\n   */\n\n\n  async _addToNodeFs(path, initialAdd, priorWh, depth, target) {\n    const ready = this.fsw._emitReady;\n\n    if (this.fsw._isIgnored(path) || this.fsw.closed) {\n      ready();\n      return false;\n    }\n\n    const wh = this.fsw._getWatchHelpers(path, depth);\n\n    if (!wh.hasGlob && priorWh) {\n      wh.hasGlob = priorWh.hasGlob;\n      wh.globFilter = priorWh.globFilter;\n\n      wh.filterPath = entry => priorWh.filterPath(entry);\n\n      wh.filterDir = entry => priorWh.filterDir(entry);\n    } // evaluate what is at the path we're being asked to watch\n\n\n    try {\n      const stats = await statMethods[wh.statMethod](wh.watchPath);\n      if (this.fsw.closed) return;\n\n      if (this.fsw._isIgnored(wh.watchPath, stats)) {\n        ready();\n        return false;\n      }\n\n      const follow = this.fsw.options.followSymlinks && !path.includes(STAR$1) && !path.includes(BRACE_START);\n      let closer;\n\n      if (stats.isDirectory()) {\n        const targetPath = follow ? await fsrealpath(path) : path;\n        if (this.fsw.closed) return;\n        closer = await this._handleDir(wh.watchPath, stats, initialAdd, depth, target, wh, targetPath);\n        if (this.fsw.closed) return; // preserve this symlink's target path\n\n        if (path !== targetPath && targetPath !== undefined) {\n          this.fsw._symlinkPaths.set(targetPath, true);\n        }\n      } else if (stats.isSymbolicLink()) {\n        const targetPath = follow ? await fsrealpath(path) : path;\n        if (this.fsw.closed) return;\n        const parent = sysPath__default['default'].dirname(wh.watchPath);\n\n        this.fsw._getWatchedDir(parent).add(wh.watchPath);\n\n        this.fsw._emit(EV_ADD, wh.watchPath, stats);\n\n        closer = await this._handleDir(parent, stats, initialAdd, depth, path, wh, targetPath);\n        if (this.fsw.closed) return; // preserve this symlink's target path\n\n        if (targetPath !== undefined) {\n          this.fsw._symlinkPaths.set(sysPath__default['default'].resolve(path), targetPath);\n        }\n      } else {\n        closer = this._handleFile(wh.watchPath, stats, initialAdd);\n      }\n\n      ready();\n\n      this.fsw._addPathCloser(path, closer);\n\n      return false;\n    } catch (error) {\n      if (this.fsw._handleError(error)) {\n        ready();\n        return path;\n      }\n    }\n  }\n\n}\n\nvar nodefsHandler = NodeFsHandler;\nconst {\n  promisify: promisify$2\n} = require$$0__default['default'];\nlet fsevents;\n\ntry {\n  fsevents = require$$1__default$1['default'];\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst {\n  EV_ADD: EV_ADD$1,\n  EV_CHANGE: EV_CHANGE$1,\n  EV_ADD_DIR: EV_ADD_DIR$1,\n  EV_UNLINK,\n  EV_ERROR: EV_ERROR$1,\n  STR_DATA: STR_DATA$1,\n  STR_END: STR_END$1,\n  FSEVENT_CREATED,\n  FSEVENT_MODIFIED,\n  FSEVENT_DELETED,\n  FSEVENT_MOVED,\n  // FSEVENT_CLONED,\n  FSEVENT_UNKNOWN,\n  FSEVENT_TYPE_FILE,\n  FSEVENT_TYPE_DIRECTORY,\n  FSEVENT_TYPE_SYMLINK,\n  ROOT_GLOBSTAR,\n  DIR_SUFFIX,\n  DOT_SLASH,\n  FUNCTION_TYPE,\n  EMPTY_FN: EMPTY_FN$1,\n  IDENTITY_FN\n} = constants$2;\n\nconst Depth = value => isNaN(value) ? {} : {\n  depth: value\n};\n\nconst stat$2 = promisify$2(fs__default['default'].stat);\nconst lstat$2 = promisify$2(fs__default['default'].lstat);\nconst realpath$1 = promisify$2(fs__default['default'].realpath);\nconst statMethods$1 = {\n  stat: stat$2,\n  lstat: lstat$2\n};\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n// fsevents instance helper functions\n\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\n\nconst FSEventsWatchers = new Map(); // Threshold of duplicate path prefixes at which to start\n// consolidating going forward\n\nconst consolidateThreshhold = 10;\nconst wrongEventFlags = new Set([69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912]);\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\n\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {\n    stop\n  };\n};\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\n\n\nfunction setFSEventsListener(path, realPath, listener, rawEmitter) {\n  let watchPath = sysPath__default['default'].extname(path) ? sysPath__default['default'].dirname(path) : path;\n  const parentPath = sysPath__default['default'].dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath); // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath__default['default'].resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath__default['default'].sep)) listener(fullPath, flags, info);\n  }; // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n\n\n  let watchedParent = false;\n\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath__default['default'].resolve(watchedPath) + sysPath__default['default'].sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (!cont.listeners.size) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  } // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n\n\n  return () => {\n    const lst = cont.listeners;\n    lst.delete(filteredListener);\n\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n} // Decide whether or not we should start a new higher-level\n// parent watcher\n\n\nconst couldConsolidate = path => {\n  let count = 0;\n\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // returns boolean indicating whether fsevents can be used\n\n\nconst canUse = () => fsevents && FSEventsWatchers.size < 128; // determines subdirectory traversal levels from root to path\n\n\nconst calcDepth = (path, root) => {\n  let i = 0;\n\n  while (!path.indexOf(root) && (path = sysPath__default['default'].dirname(path)) !== root) i++;\n\n  return i;\n}; // returns boolean indicating whether the fsevents' event info has the same type\n// as the one returned by fs.stat\n\n\nconst sameTypes = (info, stats) => info.type === FSEVENT_TYPE_DIRECTORY && stats.isDirectory() || info.type === FSEVENT_TYPE_SYMLINK && stats.isSymbolicLink() || info.type === FSEVENT_TYPE_FILE && stats.isFile();\n/**\n * @mixin\n */\n\n\nclass FsEventsHandler {\n  /**\n   * @param {import('../index').FSWatcher} fsw\n   */\n  constructor(fsw) {\n    this.fsw = fsw;\n  }\n\n  checkIgnored(path, stats) {\n    const ipaths = this.fsw._ignoredPaths;\n\n    if (this.fsw._isIgnored(path, stats)) {\n      ipaths.add(path);\n\n      if (stats && stats.isDirectory()) {\n        ipaths.add(path + ROOT_GLOBSTAR);\n      }\n\n      return true;\n    }\n\n    ipaths.delete(path);\n    ipaths.delete(path + ROOT_GLOBSTAR);\n  }\n\n  addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    const event = watchedDir.has(item) ? EV_CHANGE$1 : EV_ADD$1;\n    this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n  }\n\n  async checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    try {\n      const stats = await stat$2(path);\n      if (this.fsw.closed) return;\n\n      if (sameTypes(info, stats)) {\n        this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      } else {\n        this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    } catch (error) {\n      if (error.code === 'EACCES') {\n        this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      } else {\n        this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  }\n\n  handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    if (this.fsw.closed || this.checkIgnored(path)) return;\n\n    if (event === EV_UNLINK) {\n      const isDirectory = info.type === FSEVENT_TYPE_DIRECTORY; // suppress unlink events on never before seen files\n\n      if (isDirectory || watchedDir.has(item)) {\n        this.fsw._remove(parent, item, isDirectory);\n      }\n    } else {\n      if (event === EV_ADD$1) {\n        // track new directories\n        if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n        if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n          // push symlinks back to the top of the stack to get handled\n          const curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;\n          return this._addToFsEvents(path, false, true, curDepth);\n        } // track new paths\n        // (other than symlinks being followed, which will be tracked soon)\n\n\n        this.fsw._getWatchedDir(parent).add(item);\n      }\n      /**\n       * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n       */\n\n\n      const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n\n      this.fsw._emit(eventName, path);\n\n      if (eventName === EV_ADD_DIR$1) this._addToFsEvents(path, false, true);\n    }\n  }\n  /**\n   * Handle symlinks encountered during directory scan\n   * @param {String} watchPath  - file/dir path to be watched with fsevents\n   * @param {String} realPath   - real path (in case of symlinks)\n   * @param {Function} transform  - path transformer\n   * @param {Function} globFilter - path filter in case a glob pattern was provided\n   * @returns {Function} closer for the watcher instance\n  */\n\n\n  _watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(watchPath)) return;\n    const opts = this.fsw.options;\n\n    const watchCallback = async (fullPath, flags, info) => {\n      if (this.fsw.closed) return;\n      if (opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth) return;\n      const path = transform(sysPath__default['default'].join(watchPath, sysPath__default['default'].relative(watchPath, fullPath)));\n      if (globFilter && !globFilter(path)) return; // ensure directories are tracked\n\n      const parent = sysPath__default['default'].dirname(path);\n      const item = sysPath__default['default'].basename(path);\n\n      const watchedDir = this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent); // correct for wrong events emitted\n\n\n      if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n        if (typeof opts.ignored === FUNCTION_TYPE) {\n          let stats;\n\n          try {\n            stats = await stat$2(path);\n          } catch (error) {}\n\n          if (this.fsw.closed) return;\n          if (this.checkIgnored(path, stats)) return;\n\n          if (sameTypes(info, stats)) {\n            this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          } else {\n            this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          }\n        } else {\n          this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        switch (info.event) {\n          case FSEVENT_CREATED:\n          case FSEVENT_MODIFIED:\n            return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n\n          case FSEVENT_DELETED:\n          case FSEVENT_MOVED:\n            return this.checkExists(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      }\n    };\n\n    const closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw);\n\n    this.fsw._emitReady();\n\n    return closer;\n  }\n  /**\n   * Handle symlinks encountered during directory scan\n   * @param {String} linkPath path to symlink\n   * @param {String} fullPath absolute path to the symlink\n   * @param {Function} transform pre-existing path transformer\n   * @param {Number} curDepth level of subdirectories traversed to where symlink is\n   * @returns {Promise<void>}\n   */\n\n\n  async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n    // don't follow the same symlink more than once\n    if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n    this.fsw._symlinkPaths.set(fullPath, true);\n\n    this.fsw._incrReadyCount();\n\n    try {\n      const linkTarget = await realpath$1(linkPath);\n      if (this.fsw.closed) return;\n\n      if (this.fsw._isIgnored(linkTarget)) {\n        return this.fsw._emitReady();\n      }\n\n      this.fsw._incrReadyCount(); // add the linkTarget for watching with a wrapper for transform\n      // that causes emitted paths to incorporate the link's path\n\n\n      this._addToFsEvents(linkTarget || linkPath, path => {\n        let aliasedPath = linkPath;\n\n        if (linkTarget && linkTarget !== DOT_SLASH) {\n          aliasedPath = path.replace(linkTarget, linkPath);\n        } else if (path !== DOT_SLASH) {\n          aliasedPath = sysPath__default['default'].join(linkPath, path);\n        }\n\n        return transform(aliasedPath);\n      }, false, curDepth);\n    } catch (error) {\n      if (this.fsw._handleError(error)) {\n        return this.fsw._emitReady();\n      }\n    }\n  }\n  /**\n   *\n   * @param {Path} newPath\n   * @param {fs.Stats} stats\n   */\n\n\n  emitAdd(newPath, stats, processPath, opts, forceAdd) {\n    const pp = processPath(newPath);\n    const isDir = stats.isDirectory();\n\n    const dirObj = this.fsw._getWatchedDir(sysPath__default['default'].dirname(pp));\n\n    const base = sysPath__default['default'].basename(pp); // ensure empty dirs get tracked\n\n    if (isDir) this.fsw._getWatchedDir(pp);\n    if (dirObj.has(base)) return;\n    dirObj.add(base);\n\n    if (!opts.ignoreInitial || forceAdd === true) {\n      this.fsw._emit(isDir ? EV_ADD_DIR$1 : EV_ADD$1, pp, stats);\n    }\n  }\n\n  initWatch(realPath, path, wh, processPath) {\n    if (this.fsw.closed) return;\n\n    const closer = this._watchWithFsEvents(wh.watchPath, sysPath__default['default'].resolve(realPath || wh.watchPath), processPath, wh.globFilter);\n\n    this.fsw._addPathCloser(path, closer);\n  }\n  /**\n   * Handle added path with fsevents\n   * @param {String} path file/dir path or glob pattern\n   * @param {Function|Boolean=} transform converts working path to what the user expects\n   * @param {Boolean=} forceAdd ensure add is emitted\n   * @param {Number=} priorDepth Level of subdirectories already traversed.\n   * @returns {Promise<void>}\n   */\n\n\n  async _addToFsEvents(path, transform, forceAdd, priorDepth) {\n    if (this.fsw.closed) {\n      return;\n    }\n\n    const opts = this.fsw.options;\n    const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\n\n    const wh = this.fsw._getWatchHelpers(path); // evaluate what is at the path we're being asked to watch\n\n\n    try {\n      const stats = await statMethods$1[wh.statMethod](wh.watchPath);\n      if (this.fsw.closed) return;\n\n      if (this.fsw._isIgnored(wh.watchPath, stats)) {\n        throw null;\n      }\n\n      if (stats.isDirectory()) {\n        // emit addDir unless this is a glob parent\n        if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd); // don't recurse further if it would exceed depth setting\n\n        if (priorDepth && priorDepth > opts.depth) return; // scan the contents of the dir\n\n        this.fsw._readdirp(wh.watchPath, {\n          fileFilter: entry => wh.filterPath(entry),\n          directoryFilter: entry => wh.filterDir(entry),\n          ...Depth(opts.depth - (priorDepth || 0))\n        }).on(STR_DATA$1, entry => {\n          // need to check filterPath on dirs b/c filterDir is less restrictive\n          if (this.fsw.closed) {\n            return;\n          }\n\n          if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n          const joinedPath = sysPath__default['default'].join(wh.watchPath, entry.path);\n          const {\n            fullPath\n          } = entry;\n\n          if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n            // preserve the current depth here since it can't be derived from\n            // real paths past the symlink\n            const curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath__default['default'].resolve(wh.watchPath)) + 1;\n\n            this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n          } else {\n            this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n          }\n        }).on(EV_ERROR$1, EMPTY_FN$1).on(STR_END$1, () => {\n          this.fsw._emitReady();\n        });\n      } else {\n        this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n\n        this.fsw._emitReady();\n      }\n    } catch (error) {\n      if (!error || this.fsw._handleError(error)) {\n        // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n        this.fsw._emitReady();\n\n        this.fsw._emitReady();\n      }\n    }\n\n    if (opts.persistent && forceAdd !== true) {\n      if (typeof transform === FUNCTION_TYPE) {\n        // realpath has already been resolved\n        this.initWatch(undefined, path, wh, processPath);\n      } else {\n        let realPath;\n\n        try {\n          realPath = await realpath$1(wh.watchPath);\n        } catch (e) {}\n\n        this.initWatch(realPath, path, wh, processPath);\n      }\n    }\n  }\n\n}\n\nvar fseventsHandler = FsEventsHandler;\nvar canUse_1 = canUse;\nfseventsHandler.canUse = canUse_1;\nconst {\n  EventEmitter\n} = require$$0__default$2['default'];\nconst {\n  promisify: promisify$3\n} = require$$0__default['default'];\nconst anymatch = anymatch_1.default;\nconst {\n  EV_ALL,\n  EV_READY,\n  EV_ADD: EV_ADD$2,\n  EV_CHANGE: EV_CHANGE$2,\n  EV_UNLINK: EV_UNLINK$1,\n  EV_ADD_DIR: EV_ADD_DIR$2,\n  EV_UNLINK_DIR,\n  EV_RAW,\n  EV_ERROR: EV_ERROR$2,\n  STR_CLOSE,\n  STR_END: STR_END$2,\n  BACK_SLASH_RE,\n  DOUBLE_SLASH_RE,\n  SLASH_OR_BACK_SLASH_RE,\n  DOT_RE,\n  REPLACER_RE,\n  SLASH,\n  SLASH_SLASH,\n  BRACE_START: BRACE_START$1,\n  BANG: BANG$1,\n  ONE_DOT,\n  TWO_DOTS,\n  GLOBSTAR,\n  SLASH_GLOBSTAR,\n  ANYMATCH_OPTS,\n  STRING_TYPE,\n  FUNCTION_TYPE: FUNCTION_TYPE$1,\n  EMPTY_STR: EMPTY_STR$1,\n  EMPTY_FN: EMPTY_FN$2,\n  isWindows: isWindows$1,\n  isMacos\n} = constants$2;\nconst stat$3 = promisify$3(fs__default['default'].stat);\nconst readdir$1 = promisify$3(fs__default['default'].readdir);\n/**\n * @typedef {String} Path\n * @typedef {'all'|'add'|'addDir'|'change'|'unlink'|'unlinkDir'|'raw'|'error'|'ready'} EventName\n * @typedef {'readdir'|'watch'|'add'|'remove'|'change'} ThrottleType\n */\n\n/**\n *\n * @typedef {Object} WatchHelpers\n * @property {Boolean} followSymlinks\n * @property {'stat'|'lstat'} statMethod\n * @property {Path} path\n * @property {Path} watchPath\n * @property {Function} entryPath\n * @property {Boolean} hasGlob\n * @property {Object} globFilter\n * @property {Function} filterPath\n * @property {Function} filterDir\n */\n\nconst arrify = (value = []) => Array.isArray(value) ? value : [value];\n\nconst flatten = (list, result = []) => {\n  list.forEach(item => {\n    if (Array.isArray(item)) {\n      flatten(item, result);\n    } else {\n      result.push(item);\n    }\n  });\n  return result;\n};\n\nconst unifyPaths = paths_ => {\n  /**\n   * @type {Array<String>}\n   */\n  const paths = flatten(arrify(paths_));\n\n  if (!paths.every(p => typeof p === STRING_TYPE)) {\n    throw new TypeError(`Non-string provided as watch path: ${paths}`);\n  }\n\n  return paths.map(normalizePathToUnix);\n}; // If SLASH_SLASH occurs at the beginning of path, it is not replaced\n//     because \"//StoragePC/DrivePool/Movies\" is a valid network path\n\n\nconst toUnix = string => {\n  let str = string.replace(BACK_SLASH_RE, SLASH);\n  let prepend = false;\n\n  if (str.startsWith(SLASH_SLASH)) {\n    prepend = true;\n  }\n\n  while (str.match(DOUBLE_SLASH_RE)) {\n    str = str.replace(DOUBLE_SLASH_RE, SLASH);\n  }\n\n  if (prepend) {\n    str = SLASH + str;\n  }\n\n  return str;\n}; // Our version of upath.normalize\n// TODO: this is not equal to path-normalize module - investigate why\n\n\nconst normalizePathToUnix = path => toUnix(sysPath__default['default'].normalize(toUnix(path)));\n\nconst normalizeIgnored = (cwd = EMPTY_STR$1) => path => {\n  if (typeof path !== STRING_TYPE) return path;\n  return normalizePathToUnix(sysPath__default['default'].isAbsolute(path) ? path : sysPath__default['default'].join(cwd, path));\n};\n\nconst getAbsolutePath = (path, cwd) => {\n  if (sysPath__default['default'].isAbsolute(path)) {\n    return path;\n  }\n\n  if (path.startsWith(BANG$1)) {\n    return BANG$1 + sysPath__default['default'].join(cwd, path.slice(1));\n  }\n\n  return sysPath__default['default'].join(cwd, path);\n};\n\nconst undef = (opts, key) => opts[key] === undefined;\n/**\n * Directory entry.\n * @property {Path} path\n * @property {Set<Path>} items\n */\n\n\nclass DirEntry {\n  /**\n   * @param {Path} dir\n   * @param {Function} removeWatcher\n   */\n  constructor(dir, removeWatcher) {\n    this.path = dir;\n    this._removeWatcher = removeWatcher;\n    /** @type {Set<Path>} */\n\n    this.items = new Set();\n  }\n\n  add(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    if (item !== ONE_DOT && item !== TWO_DOTS) items.add(item);\n  }\n\n  async remove(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    items.delete(item);\n    if (items.size > 0) return;\n    const dir = this.path;\n\n    try {\n      await readdir$1(dir);\n    } catch (err) {\n      if (this._removeWatcher) {\n        this._removeWatcher(sysPath__default['default'].dirname(dir), sysPath__default['default'].basename(dir));\n      }\n    }\n  }\n\n  has(item) {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    return items.has(item);\n  }\n  /**\n   * @returns {Array<String>}\n   */\n\n\n  getChildren() {\n    const {\n      items\n    } = this;\n    if (!items) return;\n    return [...items.values()];\n  }\n\n  dispose() {\n    this.items.clear();\n    delete this.path;\n    delete this._removeWatcher;\n    delete this.items;\n    Object.freeze(this);\n  }\n\n}\n\nconst STAT_METHOD_F = 'stat';\nconst STAT_METHOD_L = 'lstat';\n\nclass WatchHelper {\n  constructor(path, watchPath, follow, fsw) {\n    this.fsw = fsw;\n    this.path = path = path.replace(REPLACER_RE, EMPTY_STR$1);\n    this.watchPath = watchPath;\n    this.fullWatchPath = sysPath__default['default'].resolve(watchPath);\n    this.hasGlob = watchPath !== path;\n    /** @type {object|boolean} */\n\n    if (path === EMPTY_STR$1) this.hasGlob = false;\n    this.globSymlink = this.hasGlob && follow ? undefined : false;\n    this.globFilter = this.hasGlob ? anymatch(path, undefined, ANYMATCH_OPTS) : false;\n    this.dirParts = this.getDirParts(path);\n    this.dirParts.forEach(parts => {\n      if (parts.length > 1) parts.pop();\n    });\n    this.followSymlinks = follow;\n    this.statMethod = follow ? STAT_METHOD_F : STAT_METHOD_L;\n  }\n\n  checkGlobSymlink(entry) {\n    // only need to resolve once\n    // first entry should always have entry.parentDir === EMPTY_STR\n    if (this.globSymlink === undefined) {\n      this.globSymlink = entry.fullParentDir === this.fullWatchPath ? false : {\n        realPath: entry.fullParentDir,\n        linkPath: this.fullWatchPath\n      };\n    }\n\n    if (this.globSymlink) {\n      return entry.fullPath.replace(this.globSymlink.realPath, this.globSymlink.linkPath);\n    }\n\n    return entry.fullPath;\n  }\n\n  entryPath(entry) {\n    return sysPath__default['default'].join(this.watchPath, sysPath__default['default'].relative(this.watchPath, this.checkGlobSymlink(entry)));\n  }\n\n  filterPath(entry) {\n    const {\n      stats\n    } = entry;\n    if (stats && stats.isSymbolicLink()) return this.filterDir(entry);\n    const resolvedPath = this.entryPath(entry);\n    const matchesGlob = this.hasGlob && typeof this.globFilter === FUNCTION_TYPE$1 ? this.globFilter(resolvedPath) : true;\n    return matchesGlob && this.fsw._isntIgnored(resolvedPath, stats) && this.fsw._hasReadPermissions(stats);\n  }\n\n  getDirParts(path) {\n    if (!this.hasGlob) return [];\n    const parts = [];\n    const expandedPath = path.includes(BRACE_START$1) ? braces_1.expand(path) : [path];\n    expandedPath.forEach(path => {\n      parts.push(sysPath__default['default'].relative(this.watchPath, path).split(SLASH_OR_BACK_SLASH_RE));\n    });\n    return parts;\n  }\n\n  filterDir(entry) {\n    if (this.hasGlob) {\n      const entryParts = this.getDirParts(this.checkGlobSymlink(entry));\n      let globstar = false;\n      this.unmatchedGlob = !this.dirParts.some(parts => {\n        return parts.every((part, i) => {\n          if (part === GLOBSTAR) globstar = true;\n          return globstar || !entryParts[0][i] || anymatch(part, entryParts[0][i], ANYMATCH_OPTS);\n        });\n      });\n    }\n\n    return !this.unmatchedGlob && this.fsw._isntIgnored(this.entryPath(entry), entry.stats);\n  }\n\n}\n/**\n * Watches files & directories for changes. Emitted events:\n * `add`, `addDir`, `change`, `unlink`, `unlinkDir`, `all`, `error`\n *\n *     new FSWatcher()\n *       .add(directories)\n *       .on('add', path => log('File', path, 'was added'))\n */\n\n\nclass FSWatcher extends EventEmitter {\n  // Not indenting methods for history sake; for now.\n  constructor(_opts) {\n    super();\n    const opts = {};\n    if (_opts) Object.assign(opts, _opts); // for frozen objects\n\n    /** @type {Map<String, DirEntry>} */\n\n    this._watched = new Map();\n    /** @type {Map<String, Array>} */\n\n    this._closers = new Map();\n    /** @type {Set<String>} */\n\n    this._ignoredPaths = new Set();\n    /** @type {Map<ThrottleType, Map>} */\n\n    this._throttled = new Map();\n    /** @type {Map<Path, String|Boolean>} */\n\n    this._symlinkPaths = new Map();\n    this._streams = new Set();\n    this.closed = false; // Set up default options.\n\n    if (undef(opts, 'persistent')) opts.persistent = true;\n    if (undef(opts, 'ignoreInitial')) opts.ignoreInitial = false;\n    if (undef(opts, 'ignorePermissionErrors')) opts.ignorePermissionErrors = false;\n    if (undef(opts, 'interval')) opts.interval = 100;\n    if (undef(opts, 'binaryInterval')) opts.binaryInterval = 300;\n    if (undef(opts, 'disableGlobbing')) opts.disableGlobbing = false;\n    opts.enableBinaryInterval = opts.binaryInterval !== opts.interval; // Enable fsevents on OS X when polling isn't explicitly enabled.\n\n    if (undef(opts, 'useFsEvents')) opts.useFsEvents = !opts.usePolling; // If we can't use fsevents, ensure the options reflect it's disabled.\n\n    const canUseFsEvents = fseventsHandler.canUse();\n    if (!canUseFsEvents) opts.useFsEvents = false; // Use polling on Mac if not using fsevents.\n    // Other platforms use non-polling fs_watch.\n\n    if (undef(opts, 'usePolling') && !opts.useFsEvents) {\n      opts.usePolling = isMacos;\n    } // Global override (useful for end-developers that need to force polling for all\n    // instances of chokidar, regardless of usage/dependency depth)\n\n\n    const envPoll = process.env.CHOKIDAR_USEPOLLING;\n\n    if (envPoll !== undefined) {\n      const envLower = envPoll.toLowerCase();\n\n      if (envLower === 'false' || envLower === '0') {\n        opts.usePolling = false;\n      } else if (envLower === 'true' || envLower === '1') {\n        opts.usePolling = true;\n      } else {\n        opts.usePolling = !!envLower;\n      }\n    }\n\n    const envInterval = process.env.CHOKIDAR_INTERVAL;\n\n    if (envInterval) {\n      opts.interval = Number.parseInt(envInterval, 10);\n    } // Editor atomic write normalization enabled by default with fs.watch\n\n\n    if (undef(opts, 'atomic')) opts.atomic = !opts.usePolling && !opts.useFsEvents;\n    if (opts.atomic) this._pendingUnlinks = new Map();\n    if (undef(opts, 'followSymlinks')) opts.followSymlinks = true;\n    if (undef(opts, 'awaitWriteFinish')) opts.awaitWriteFinish = false;\n    if (opts.awaitWriteFinish === true) opts.awaitWriteFinish = {};\n    const awf = opts.awaitWriteFinish;\n\n    if (awf) {\n      if (!awf.stabilityThreshold) awf.stabilityThreshold = 2000;\n      if (!awf.pollInterval) awf.pollInterval = 100;\n      this._pendingWrites = new Map();\n    }\n\n    if (opts.ignored) opts.ignored = arrify(opts.ignored);\n    let readyCalls = 0;\n\n    this._emitReady = () => {\n      readyCalls++;\n\n      if (readyCalls >= this._readyCount) {\n        this._emitReady = EMPTY_FN$2;\n        this._readyEmitted = true; // use process.nextTick to allow time for listener to be bound\n\n        process.nextTick(() => this.emit(EV_READY));\n      }\n    };\n\n    this._emitRaw = (...args) => this.emit(EV_RAW, ...args);\n\n    this._readyEmitted = false;\n    this.options = opts; // Initialize with proper watcher.\n\n    if (opts.useFsEvents) {\n      this._fsEventsHandler = new fseventsHandler(this);\n    } else {\n      this._nodeFsHandler = new nodefsHandler(this);\n    } // Youre frozen when your hearts not open.\n\n\n    Object.freeze(opts);\n  } // Public methods\n\n  /**\n   * Adds paths to be watched on an existing FSWatcher instance\n   * @param {Path|Array<Path>} paths_\n   * @param {String=} _origAdd private; for handling non-existent paths to be watched\n   * @param {Boolean=} _internal private; indicates a non-user add\n   * @returns {FSWatcher} for chaining\n   */\n\n\n  add(paths_, _origAdd, _internal) {\n    const {\n      cwd,\n      disableGlobbing\n    } = this.options;\n    this.closed = false;\n    let paths = unifyPaths(paths_);\n\n    if (cwd) {\n      paths = paths.map(path => {\n        const absPath = getAbsolutePath(path, cwd); // Check `path` instead of `absPath` because the cwd portion can't be a glob\n\n        if (disableGlobbing || !isGlob(path)) {\n          return absPath;\n        }\n\n        return normalizePath(absPath);\n      });\n    } // set aside negated glob strings\n\n\n    paths = paths.filter(path => {\n      if (path.startsWith(BANG$1)) {\n        this._ignoredPaths.add(path.slice(1));\n\n        return false;\n      } // if a path is being added that was previously ignored, stop ignoring it\n\n\n      this._ignoredPaths.delete(path);\n\n      this._ignoredPaths.delete(path + SLASH_GLOBSTAR); // reset the cached userIgnored anymatch fn\n      // to make ignoredPaths changes effective\n\n\n      this._userIgnored = undefined;\n      return true;\n    });\n\n    if (this.options.useFsEvents && this._fsEventsHandler) {\n      if (!this._readyCount) this._readyCount = paths.length;\n      if (this.options.persistent) this._readyCount *= 2;\n      paths.forEach(path => this._fsEventsHandler._addToFsEvents(path));\n    } else {\n      if (!this._readyCount) this._readyCount = 0;\n      this._readyCount += paths.length;\n      Promise.all(paths.map(async path => {\n        const res = await this._nodeFsHandler._addToNodeFs(path, !_internal, 0, 0, _origAdd);\n        if (res) this._emitReady();\n        return res;\n      })).then(results => {\n        if (this.closed) return;\n        results.filter(item => item).forEach(item => {\n          this.add(sysPath__default['default'].dirname(item), sysPath__default['default'].basename(_origAdd || item));\n        });\n      });\n    }\n\n    return this;\n  }\n  /**\n   * Close watchers or start ignoring events from specified paths.\n   * @param {Path|Array<Path>} paths_ - string or array of strings, file/directory paths and/or globs\n   * @returns {FSWatcher} for chaining\n  */\n\n\n  unwatch(paths_) {\n    if (this.closed) return this;\n    const paths = unifyPaths(paths_);\n    const {\n      cwd\n    } = this.options;\n    paths.forEach(path => {\n      // convert to absolute path unless relative path already matches\n      if (!sysPath__default['default'].isAbsolute(path) && !this._closers.has(path)) {\n        if (cwd) path = sysPath__default['default'].join(cwd, path);\n        path = sysPath__default['default'].resolve(path);\n      }\n\n      this._closePath(path);\n\n      this._ignoredPaths.add(path);\n\n      if (this._watched.has(path)) {\n        this._ignoredPaths.add(path + SLASH_GLOBSTAR);\n      } // reset the cached userIgnored anymatch fn\n      // to make ignoredPaths changes effective\n\n\n      this._userIgnored = undefined;\n    });\n    return this;\n  }\n  /**\n   * Close watchers and remove all listeners from watched paths.\n   * @returns {Promise<void>}.\n  */\n\n\n  close() {\n    if (this.closed) return this._closePromise;\n    this.closed = true; // Memory management.\n\n    this.removeAllListeners();\n    const closers = [];\n\n    this._closers.forEach(closerList => closerList.forEach(closer => {\n      const promise = closer();\n      if (promise instanceof Promise) closers.push(promise);\n    }));\n\n    this._streams.forEach(stream => stream.destroy());\n\n    this._userIgnored = undefined;\n    this._readyCount = 0;\n    this._readyEmitted = false;\n\n    this._watched.forEach(dirent => dirent.dispose());\n\n    ['closers', 'watched', 'streams', 'symlinkPaths', 'throttled'].forEach(key => {\n      this[`_${key}`].clear();\n    });\n    this._closePromise = closers.length ? Promise.all(closers).then(() => undefined) : Promise.resolve();\n    return this._closePromise;\n  }\n  /**\n   * Expose list of watched paths\n   * @returns {Object} for chaining\n  */\n\n\n  getWatched() {\n    const watchList = {};\n\n    this._watched.forEach((entry, dir) => {\n      const key = this.options.cwd ? sysPath__default['default'].relative(this.options.cwd, dir) : dir;\n      watchList[key || ONE_DOT] = entry.getChildren().sort();\n    });\n\n    return watchList;\n  }\n\n  emitWithAll(event, args) {\n    this.emit(...args);\n    if (event !== EV_ERROR$2) this.emit(EV_ALL, ...args);\n  } // Common helpers\n  // --------------\n\n  /**\n   * Normalize and emit events.\n   * Calling _emit DOES NOT MEAN emit() would be called!\n   * @param {EventName} event Type of event\n   * @param {Path} path File or directory path\n   * @param {*=} val1 arguments to be passed with event\n   * @param {*=} val2\n   * @param {*=} val3\n   * @returns the error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n   */\n\n\n  async _emit(event, path, val1, val2, val3) {\n    if (this.closed) return;\n    const opts = this.options;\n    if (isWindows$1) path = sysPath__default['default'].normalize(path);\n    if (opts.cwd) path = sysPath__default['default'].relative(opts.cwd, path);\n    /** @type Array<any> */\n\n    const args = [event, path];\n    if (val3 !== undefined) args.push(val1, val2, val3);else if (val2 !== undefined) args.push(val1, val2);else if (val1 !== undefined) args.push(val1);\n    const awf = opts.awaitWriteFinish;\n    let pw;\n\n    if (awf && (pw = this._pendingWrites.get(path))) {\n      pw.lastChange = new Date();\n      return this;\n    }\n\n    if (opts.atomic) {\n      if (event === EV_UNLINK$1) {\n        this._pendingUnlinks.set(path, args);\n\n        setTimeout(() => {\n          this._pendingUnlinks.forEach((entry, path) => {\n            this.emit(...entry);\n            this.emit(EV_ALL, ...entry);\n\n            this._pendingUnlinks.delete(path);\n          });\n        }, typeof opts.atomic === 'number' ? opts.atomic : 100);\n        return this;\n      }\n\n      if (event === EV_ADD$2 && this._pendingUnlinks.has(path)) {\n        event = args[0] = EV_CHANGE$2;\n\n        this._pendingUnlinks.delete(path);\n      }\n    }\n\n    if (awf && (event === EV_ADD$2 || event === EV_CHANGE$2) && this._readyEmitted) {\n      const awfEmit = (err, stats) => {\n        if (err) {\n          event = args[0] = EV_ERROR$2;\n          args[1] = err;\n          this.emitWithAll(event, args);\n        } else if (stats) {\n          // if stats doesn't exist the file must have been deleted\n          if (args.length > 2) {\n            args[2] = stats;\n          } else {\n            args.push(stats);\n          }\n\n          this.emitWithAll(event, args);\n        }\n      };\n\n      this._awaitWriteFinish(path, awf.stabilityThreshold, event, awfEmit);\n\n      return this;\n    }\n\n    if (event === EV_CHANGE$2) {\n      const isThrottled = !this._throttle(EV_CHANGE$2, path, 50);\n      if (isThrottled) return this;\n    }\n\n    if (opts.alwaysStat && val1 === undefined && (event === EV_ADD$2 || event === EV_ADD_DIR$2 || event === EV_CHANGE$2)) {\n      const fullPath = opts.cwd ? sysPath__default['default'].join(opts.cwd, path) : path;\n      let stats;\n\n      try {\n        stats = await stat$3(fullPath);\n      } catch (err) {} // Suppress event when fs_stat fails, to avoid sending undefined 'stat'\n\n\n      if (!stats || this.closed) return;\n      args.push(stats);\n    }\n\n    this.emitWithAll(event, args);\n    return this;\n  }\n  /**\n   * Common handler for errors\n   * @param {Error} error\n   * @returns {Error|Boolean} The error if defined, otherwise the value of the FSWatcher instance's `closed` flag\n   */\n\n\n  _handleError(error) {\n    const code = error && error.code;\n\n    if (error && code !== 'ENOENT' && code !== 'ENOTDIR' && (!this.options.ignorePermissionErrors || code !== 'EPERM' && code !== 'EACCES')) {\n      this.emit(EV_ERROR$2, error);\n    }\n\n    return error || this.closed;\n  }\n  /**\n   * Helper utility for throttling\n   * @param {ThrottleType} actionType type being throttled\n   * @param {Path} path being acted upon\n   * @param {Number} timeout duration of time to suppress duplicate actions\n   * @returns {Object|false} tracking object or false if action should be suppressed\n   */\n\n\n  _throttle(actionType, path, timeout) {\n    if (!this._throttled.has(actionType)) {\n      this._throttled.set(actionType, new Map());\n    }\n    /** @type {Map<Path, Object>} */\n\n\n    const action = this._throttled.get(actionType);\n    /** @type {Object} */\n\n\n    const actionPath = action.get(path);\n\n    if (actionPath) {\n      actionPath.count++;\n      return false;\n    }\n\n    let timeoutObject;\n\n    const clear = () => {\n      const item = action.get(path);\n      const count = item ? item.count : 0;\n      action.delete(path);\n      clearTimeout(timeoutObject);\n      if (item) clearTimeout(item.timeoutObject);\n      return count;\n    };\n\n    timeoutObject = setTimeout(clear, timeout);\n    const thr = {\n      timeoutObject,\n      clear,\n      count: 0\n    };\n    action.set(path, thr);\n    return thr;\n  }\n\n  _incrReadyCount() {\n    return this._readyCount++;\n  }\n  /**\n   * Awaits write operation to finish.\n   * Polls a newly created file for size variations. When files size does not change for 'threshold' milliseconds calls callback.\n   * @param {Path} path being acted upon\n   * @param {Number} threshold Time in milliseconds a file size must be fixed before acknowledging write OP is finished\n   * @param {EventName} event\n   * @param {Function} awfEmit Callback to be called when ready for event to be emitted.\n   */\n\n\n  _awaitWriteFinish(path, threshold, event, awfEmit) {\n    let timeoutHandler;\n    let fullPath = path;\n\n    if (this.options.cwd && !sysPath__default['default'].isAbsolute(path)) {\n      fullPath = sysPath__default['default'].join(this.options.cwd, path);\n    }\n\n    const now = new Date();\n\n    const awaitWriteFinish = prevStat => {\n      fs__default['default'].stat(fullPath, (err, curStat) => {\n        if (err || !this._pendingWrites.has(path)) {\n          if (err && err.code !== 'ENOENT') awfEmit(err);\n          return;\n        }\n\n        const now = Number(new Date());\n\n        if (prevStat && curStat.size !== prevStat.size) {\n          this._pendingWrites.get(path).lastChange = now;\n        }\n\n        const pw = this._pendingWrites.get(path);\n\n        const df = now - pw.lastChange;\n\n        if (df >= threshold) {\n          this._pendingWrites.delete(path);\n\n          awfEmit(undefined, curStat);\n        } else {\n          timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval, curStat);\n        }\n      });\n    };\n\n    if (!this._pendingWrites.has(path)) {\n      this._pendingWrites.set(path, {\n        lastChange: now,\n        cancelWait: () => {\n          this._pendingWrites.delete(path);\n\n          clearTimeout(timeoutHandler);\n          return event;\n        }\n      });\n\n      timeoutHandler = setTimeout(awaitWriteFinish, this.options.awaitWriteFinish.pollInterval);\n    }\n  }\n\n  _getGlobIgnored() {\n    return [...this._ignoredPaths.values()];\n  }\n  /**\n   * Determines whether user has asked to ignore this path.\n   * @param {Path} path filepath or dir\n   * @param {fs.Stats=} stats result of fs.stat\n   * @returns {Boolean}\n   */\n\n\n  _isIgnored(path, stats) {\n    if (this.options.atomic && DOT_RE.test(path)) return true;\n\n    if (!this._userIgnored) {\n      const {\n        cwd\n      } = this.options;\n      const ign = this.options.ignored;\n      const ignored = ign && ign.map(normalizeIgnored(cwd));\n      const paths = arrify(ignored).filter(path => typeof path === STRING_TYPE && !isGlob(path)).map(path => path + SLASH_GLOBSTAR);\n\n      const list = this._getGlobIgnored().map(normalizeIgnored(cwd)).concat(ignored, paths);\n\n      this._userIgnored = anymatch(list, undefined, ANYMATCH_OPTS);\n    }\n\n    return this._userIgnored([path, stats]);\n  }\n\n  _isntIgnored(path, stat) {\n    return !this._isIgnored(path, stat);\n  }\n  /**\n   * Provides a set of common helpers and properties relating to symlink and glob handling.\n   * @param {Path} path file, directory, or glob pattern being watched\n   * @param {Number=} depth at any depth > 0, this isn't a glob\n   * @returns {WatchHelper} object containing helpers for this path\n   */\n\n\n  _getWatchHelpers(path, depth) {\n    const watchPath = depth || this.options.disableGlobbing || !isGlob(path) ? path : globParent(path);\n    const follow = this.options.followSymlinks;\n    return new WatchHelper(path, watchPath, follow, this);\n  } // Directory helpers\n  // -----------------\n\n  /**\n   * Provides directory tracking objects\n   * @param {String} directory path of the directory\n   * @returns {DirEntry} the directory's tracking object\n   */\n\n\n  _getWatchedDir(directory) {\n    if (!this._boundRemove) this._boundRemove = this._remove.bind(this);\n    const dir = sysPath__default['default'].resolve(directory);\n    if (!this._watched.has(dir)) this._watched.set(dir, new DirEntry(dir, this._boundRemove));\n    return this._watched.get(dir);\n  } // File helpers\n  // ------------\n\n  /**\n   * Check for read permissions.\n   * Based on this answer on SO: https://stackoverflow.com/a/11781404/1358405\n   * @param {fs.Stats} stats - object, result of fs_stat\n   * @returns {Boolean} indicates whether the file can be read\n  */\n\n\n  _hasReadPermissions(stats) {\n    if (this.options.ignorePermissionErrors) return true; // stats.mode may be bigint\n\n    const md = stats && Number.parseInt(stats.mode, 10);\n    const st = md & 0o777;\n    const it = Number.parseInt(st.toString(8)[0], 10);\n    return Boolean(4 & it);\n  }\n  /**\n   * Handles emitting unlink events for\n   * files and directories, and via recursion, for\n   * files and directories within directories that are unlinked\n   * @param {String} directory within which the following item is located\n   * @param {String} item      base path of item/directory\n   * @returns {void}\n  */\n\n\n  _remove(directory, item, isDirectory) {\n    // if what is being deleted is a directory, get that directory's paths\n    // for recursive deleting and cleaning of watched object\n    // if it is not a directory, nestedDirectoryChildren will be empty array\n    const path = sysPath__default['default'].join(directory, item);\n    const fullPath = sysPath__default['default'].resolve(path);\n    isDirectory = isDirectory != null ? isDirectory : this._watched.has(path) || this._watched.has(fullPath); // prevent duplicate handling in case of arriving here nearly simultaneously\n    // via multiple paths (such as _handleFile and _handleDir)\n\n    if (!this._throttle('remove', path, 100)) return; // if the only watched file is removed, watch for its return\n\n    if (!isDirectory && !this.options.useFsEvents && this._watched.size === 1) {\n      this.add(directory, item, true);\n    } // This will create a new entry in the watched object in either case\n    // so we got to do the directory check beforehand\n\n\n    const wp = this._getWatchedDir(path);\n\n    const nestedDirectoryChildren = wp.getChildren(); // Recursively remove children directories / files.\n\n    nestedDirectoryChildren.forEach(nested => this._remove(path, nested)); // Check if item was on the watched list and remove it\n\n    const parent = this._getWatchedDir(directory);\n\n    const wasTracked = parent.has(item);\n    parent.remove(item); // If we wait for this file to be fully written, cancel the wait.\n\n    let relPath = path;\n    if (this.options.cwd) relPath = sysPath__default['default'].relative(this.options.cwd, path);\n\n    if (this.options.awaitWriteFinish && this._pendingWrites.has(relPath)) {\n      const event = this._pendingWrites.get(relPath).cancelWait();\n\n      if (event === EV_ADD$2) return;\n    } // The Entry will either be a directory that just got removed\n    // or a bogus entry to a file, in either case we have to remove it\n\n\n    this._watched.delete(path);\n\n    this._watched.delete(fullPath);\n\n    const eventName = isDirectory ? EV_UNLINK_DIR : EV_UNLINK$1;\n    if (wasTracked && !this._isIgnored(path)) this._emit(eventName, path); // Avoid conflicts if we later create another file with the same name\n\n    if (!this.options.useFsEvents) {\n      this._closePath(path);\n    }\n  }\n  /**\n   * Closes all watchers for a path\n   * @param {Path} path\n   */\n\n\n  _closePath(path) {\n    this._closeFile(path);\n\n    const dir = sysPath__default['default'].dirname(path);\n\n    this._getWatchedDir(dir).remove(sysPath__default['default'].basename(path));\n  }\n  /**\n   * Closes only file-specific watchers\n   * @param {Path} path\n   */\n\n\n  _closeFile(path) {\n    const closers = this._closers.get(path);\n\n    if (!closers) return;\n    closers.forEach(closer => closer());\n\n    this._closers.delete(path);\n  }\n  /**\n   *\n   * @param {Path} path\n   * @param {Function} closer\n   */\n\n\n  _addPathCloser(path, closer) {\n    if (!closer) return;\n\n    let list = this._closers.get(path);\n\n    if (!list) {\n      list = [];\n\n      this._closers.set(path, list);\n    }\n\n    list.push(closer);\n  }\n\n  _readdirp(root, opts) {\n    if (this.closed) return;\n    const options = {\n      type: EV_ALL,\n      alwaysStat: true,\n      lstat: true,\n      ...opts\n    };\n    let stream = readdirp_1(root, options);\n\n    this._streams.add(stream);\n\n    stream.once(STR_CLOSE, () => {\n      stream = undefined;\n    });\n    stream.once(STR_END$2, () => {\n      if (stream) {\n        this._streams.delete(stream);\n\n        stream = undefined;\n      }\n    });\n    return stream;\n  }\n\n} // Export FSWatcher class\n\n\nvar FSWatcher_1 = FSWatcher;\n/**\n * Instantiates watcher with paths to be tracked.\n * @param {String|Array<String>} paths file/directory paths and/or globs\n * @param {Object=} options chokidar opts\n * @returns an instance of FSWatcher for chaining.\n */\n\nconst watch = (paths, options) => {\n  const watcher = new FSWatcher(options);\n  watcher.add(paths);\n  return watcher;\n};\n\nvar watch_1 = watch;\nvar chokidar = {\n  FSWatcher: FSWatcher_1,\n  watch: watch_1\n};\nvar chokidar$1 = chokidar;\nvar dependencies = {\n  chokidar: chokidar$1\n};\nexports.chokidar = chokidar$1;\nexports.default = dependencies;\n",
            "created": "20200918082738108",
            "creator": "LinOnetwo",
            "modified": "20200918082738329",
            "module-type": "library",
            "type": "application/javascript"
        },
        "$:/plugins/linonetwo/watch-fs/FileSystemMonitor.js": {
            "title": "$:/plugins/linonetwo/watch-fs/FileSystemMonitor.js",
            "text": "/* eslint-disable global-require */\n/* eslint-disable unicorn/filename-case */\n/* \\\n  title: $:/plugins/linonetwo/watch-fs/FileSystemMonitor.js\n  type: application/javascript\n  module-type: startup\n\n  This file is modified based on $:/plugins/OokTech/Bob/FileSystemMonitor.js\n\\ */\n\nfunction FileSystemMonitor() {\n  const isDebug = true;\n  const debugLog = isDebug ? console.log : () => {};\n\n  exports.name = 'watch-fs_FileSystemMonitor';\n  exports.after = ['load-modules', 'watch-fs_watch'];\n  exports.platforms = ['node'];\n  exports.synchronous = true;\n\n  // this allow us to test this module in nodejs directly without \"ReferenceError: $tw is not defined\"\n  const $tw = this.$tw || { node: true };\n  // init our namespace for communication\n  $tw.wiki.watchFs = {};\n  // folder to watch\n  // non-tiddler files that needs to be ignored\n\n  if (typeof $tw === 'undefined' || !$tw?.node) return;\n  const deepEqual = require('./deep-equal');\n  const fs = require('fs');\n  const path = require('path');\n\n  const watchPathBase = path.resolve(\n    $tw.boot.wikiInfo?.config?.watchFolder || $tw.boot.wikiTiddlersPath || './tiddlers',\n  );\n  debugLog(`watchPathBase`, JSON.stringify(watchPathBase, undefined, '  '));\n\n  /**\n   * $tw.boot.files: {\n   *   [tiddlerTitle: string]: {\n   *     filepath: '/Users/linonetwo/xxxx/wiki/Meme-of-LinOnetwo/tiddlers/tiddlerTitle.tid',\n   *     type: 'application/x-tiddler',\n   *     hasMetaFile: false\n   *   }\n   * }\n   */\n  const initialLoadedFiles = $tw.boot.files;\n\n  /**\n   * we can use this for getTitleByPath\n   * {\n   *   [filepath: string]: {\n   *     filepath: '/Users/linonetwo/xxxx/wiki/Meme-of-LinOnetwo/tiddlers/tiddlerTitle.tid',\n   *     tiddlerTitle: string,\n   *     type: 'application/x-tiddler',\n   *     hasMetaFile: false\n   *   }\n   * }\n   */\n  const inverseFilesIndex = {};\n  $tw.wiki.watchFs.inverseFilesIndex = inverseFilesIndex;\n  // initialize the inverse index\n  for (const tiddlerTitle in initialLoadedFiles) {\n    if ({}.hasOwnProperty.call(initialLoadedFiles, tiddlerTitle)) {\n      const fileDescriptor = initialLoadedFiles[tiddlerTitle];\n      const fileRelativePath = path.relative(watchPathBase, fileDescriptor.filepath);\n      inverseFilesIndex[fileRelativePath] = { ...fileDescriptor, filepath: fileRelativePath, tiddlerTitle };\n    }\n  }\n\n  // Helpers to maintain our cached index for file path and tiddler title\n  const updateInverseIndex = (filePath, fileDescriptor) => { \n    if (fileDescriptor) {\n      inverseFilesIndex[filePath] = fileDescriptor;\n    } else {\n      delete inverseFilesIndex[filePath];\n    }\n  };\n  const filePathExistsInIndex = filePath => !!inverseFilesIndex[filePath];\n  const getTitleByPath = filePath => {\n    try {\n      return inverseFilesIndex[filePath].tiddlerTitle;\n    } catch {\n      // fatal error, shutting down.\n      watcher.close();\n      throw new Error(`${filePath}\\n not existed in watch-fs plugin's FileSystemMonitor's inverseFilesIndex`);\n    }\n  };\n  /**\n   * This is a rarely used function maybe only when user rename a tiddler on the disk,\n   * we need to get old tiddler path by its name\n   * @param {string} title\n   */\n  const getPathByTitle = title => {\n    try {\n      for (const filePath in inverseFilesIndex) {\n        if (inverseFilesIndex[filePath].title === title || inverseFilesIndex[filePath].title === `${title}.tid`) {\n          return filePath;\n        }\n      }\n      throw new Error('getPathByTitle');\n    } catch {\n      // fatal error, shutting down.\n      watcher.close();\n      throw new Error(`${title}\\n not existed in watch-fs plugin's FileSystemMonitor's inverseFilesIndex`);\n    }\n  };\n\n  /**\n   * A mutex to ignore temporary file created or deleted by this plugin.\n   *\n   * Set<filePath: string>\n   */\n  const lockedFiles = new Set();\n\n  // every time a file changed, refresh the count down timer, so only when disk get stable after a while, will we sync to the browser\n  $tw.wiki.watchFs.canSync = false;\n  const debounceInterval = 4 * 1000;\n  let syncTimeoutHandler = undefined;\n  const refreshCanSyncState = () => {\n    $tw.wiki.watchFs.canSync = false;\n    debugLog(`canSync is now ${$tw.wiki.watchFs.canSync}`);\n    clearTimeout(syncTimeoutHandler);\n    syncTimeoutHandler = setTimeout(() => {\n      $tw.wiki.watchFs.canSync = true;\n      debugLog(`canSync is now ${$tw.wiki.watchFs.canSync}`);\n    }, debounceInterval);\n  };\n\n  /**\n   * This watches for changes to a folder and updates the wiki when anything changes in the folder.\n   *\n   * The filePath reported by listener is not the actual tiddler name, and all tiddlywiki operations requires that we have the name of tiddler,\n   * So we have get tiddler name by path from `$tw.boot.files`.\n   *\n   * Then we can perform following logic:\n   * File update -> update or create tiddler using `$tw.syncadaptor.wiki.addTiddler`\n   * File remove & tiddler exist in wiki -> then remove tiddler using `$tw.syncadaptor.wiki.deleteTiddler`\n   * File remove & tiddler not exist in wiki -> This change is caused by tiddlywiki itself, do noting here\n   *\n   * @param {\"update\" | \"remove\"} changeType\n   * @param {*} filePath changed file's relative path to the folder executing this watcher\n   */\n  const listener = (changeType, filePath) => {\n    const fileRelativePath = path.relative(watchPathBase, filePath);\n    const fileAbsolutePath = path.join(watchPathBase, fileRelativePath);\n    debugLog(`${fileRelativePath} ${changeType}`);\n    if (lockedFiles.has(fileRelativePath)) {\n      debugLog(`${fileRelativePath} ignored due to mutex lock`);\n      // release lock as we have already finished our job\n      lockedFiles.delete(fileRelativePath);\n      return;\n    }\n    // on create or modify\n    if (changeType === 'add' || changeType === 'change') {\n      // get tiddler from the disk\n      /**\n       * tiddlersDescriptor:\n       * {\n       *    \"filepath\": \"Meme-of-LinOnetwo/tiddlers/$__StoryList.tid\",\n       *    \"type\": \"application/x-tiddler\",\n       *    \"tiddlers\": [\n       *      {\n       *        \"title\": \"$:/StoryList\",\n       *        \"list\": \"Index\"\n       *      }\n       *    ],\n       *    \"hasMetaFile\": false\n       *  }\n       */\n      let tiddlersDescriptor;\n      // sometimes this file get removed by wiki before we can get it, for example, Draft tiddler done editing, it get removed, and we got ENOENT here\n      try {\n        tiddlersDescriptor = $tw.loadTiddlersFromFile(fileAbsolutePath, { title: fileAbsolutePath });\n      } catch (error) {\n        debugLog(error);\n        return;\n      }\n      debugLog(`tiddlersDescriptor`, JSON.stringify(tiddlersDescriptor, undefined, '  '));\n      const { tiddlers, ...fileDescriptor } = tiddlersDescriptor;\n      // if user is using git or VSCode to create new file in the disk, that is not yet exist in the wiki\n      // but maybe our index is not updated, or maybe user is modify a system tiddler, we need to check each case\n      if (!filePathExistsInIndex(fileRelativePath)) {\n        tiddlers.forEach(tiddler => {\n          // check whether we are rename an existed tiddler\n          debugLog('getting new tiddler.title', tiddler.title);\n          const existedWikiRecord = $tw.wiki.getTiddler(tiddler.title);\n          if (existedWikiRecord && deepEqual(tiddler, existedWikiRecord.fields)) {\n            // because disk file and wiki tiddler is identical, so this file creation is triggered by wiki.\n            // We just update the index.\n            // But it might also be user changing the name of the file, so filename to be different with the actual tiddler title, while tiddler content is still same as old one\n            // We allow filename to be different with the tiddler title, but we need to handle this in the inverse index to prevent the error that we can't get tiddler from index by its path\n            debugLog('fileDescriptor.tiddlerTitle', fileDescriptor.tiddlerTitle);\n            if (\n              fileDescriptor.tiddlerTitle &&\n              fileDescriptor.tiddlerTitle !== `${tiddler.title}.tid` &&\n              fileDescriptor.tiddlerTitle !== tiddler.title\n            ) {\n              // We have no API in tw to inform $tw about we have a file changed its name, but remain its tiddler title\n              // because to do that now we have to use `$tw.syncadaptor.wiki.addTiddler(tiddler);`, which will create a new file with the title we pass to it, it can't assign a disk file name while create a new tiddler\n              throw new Error('Rename filename is not supported, please submit your idea to improve this logic');\n              // updateInverseIndex(fileRelativePath, { ...fileDescriptor, tiddlerTitle: tiddler.title });\n            } else {\n              updateInverseIndex(fileRelativePath, { ...fileDescriptor, tiddlerTitle: tiddler.title });\n            }\n          } else {\n            updateInverseIndex(fileRelativePath, { ...fileDescriptor, tiddlerTitle: tiddler.title });\n            $tw.syncadaptor.wiki.addTiddler(tiddler);\n          }\n        });\n      } else {\n        // if it already existed in the wiki, this change might 1. due to our last call to `$tw.syncadaptor.wiki.addTiddler`; 2. due to user change in git or VSCode\n        // so we have to check whether tiddler in the disk is identical to the one in the wiki, if so, we ignore it in the case 1.\n        tiddlers\n          .filter(tiddler => {\n            debugLog('updating existed tiddler', tiddler.title);\n            const { fields: tiddlerInWiki } = $tw.wiki.getTiddler(tiddler.title);\n            if (deepEqual(tiddler, tiddlerInWiki)) {\n              debugLog('Ignore update due to detect this is a change from the Browser', tiddler.title);\n              return false;\n            }\n            // if user is continuously editing, after last trigger of listener, we have waste too many time in fs, and now $tw.wiki.getTiddler get a new tiddler that is just updated by user from the wiki\n            // then our $tw.loadTiddlersFromFile's tiddler will have an old timestamp than it, ignore this case, since it means we are editing from the wiki\n            // if both are created before, and just modified now\n            if (tiddler.modified && tiddlerInWiki.modified && tiddlerInWiki.modified > tiddler.modified) {\n              debugLog('Ignore update due to there is latest change from the Browser', tiddler.title);\n              return false;\n            }\n\n            debugLog('Saving updated', tiddler.title);\n            return true;\n          })\n          // then we update wiki with each newly created tiddler\n          .forEach(tiddler => {\n            $tw.syncadaptor.wiki.addTiddler(tiddler);\n          });\n      }\n    }\n\n    // on delete\n    if (changeType === 'unlink') {\n      const tiddlerTitle = getTitleByPath(fileRelativePath);\n\n      // if this tiddler is not existed in the wiki, this means this deletion is triggered by wiki\n      // we only react on event that triggered by the git or VSCode\n      const existedTiddlerResult = $tw.wiki.getTiddler(tiddlerTitle);\n      debugLog('existedTiddlerResult', existedTiddlerResult);\n      if (!existedTiddlerResult) {\n        debugLog('file already deleted by wiki', fileAbsolutePath);\n        updateInverseIndex(fileRelativePath);\n      } else {\n        // now event is triggered by the git or VSCode\n        // ask tiddlywiki to delete the file, we first need to create a fake file for it to delete\n        // can't directly use $tw.wiki.syncadaptor.deleteTiddler(tiddlerTitle);  because it will try to modify fs, and will failed:\n        /* Sync error while processing delete of 'blabla': Error: ENOENT: no such file or directory, unlink '/Users//Desktop/repo/wiki/Meme-of-LinOnetwo/tiddlers/blabla.tid'\n          syncer-server-filesystem: Dispatching 'delete' task: blabla \n          Sync error while processing delete of 'blabla': Error: ENOENT: no such file or directory, unlink '/Users//Desktop/repo/wiki/Meme-of-LinOnetwo/tiddlers/blabla.tid' */\n        lockedFiles.add(fileRelativePath);\n        debugLog('trying to delete', fileAbsolutePath);\n        fs.writeFile(fileAbsolutePath, '', {}, () => {\n          // we may also need to provide a .meta file for wiki to delete\n          const metaFileAbsolutePath = `${fileAbsolutePath}.meta`;\n          if (!fileAbsolutePath.endsWith('.tid')) {\n            fs.writeFileSync(metaFileAbsolutePath, '');\n          }\n          $tw.syncadaptor.wiki.deleteTiddler(tiddlerTitle);\n          // sometime deleting system tiddler will result in an empty file, we need to try delete that empty file\n          try {\n            if (\n              fileAbsolutePath.startsWith('$') &&\n              fs.existsSync(fileAbsolutePath) &&\n              fs.readFileSync(fileAbsolutePath, 'utf-8').length === 0\n            ) {\n              fs.unlinkSync(fileAbsolutePath);\n            }\n          } catch (error) {\n            console.error(error);\n          }\n          updateInverseIndex(fileRelativePath);\n        });\n      }\n    }\n\n    refreshCanSyncState();\n  };\n\n  const ext = require('./3rds');\n  const watcher = ext.chokidar.watch(watchPathBase, {\n    ignoreInitial: true,\n    ignored: [\n      '**/*.meta', // TODO: deal with field change in meta file\n      '**/$__StoryList*',\n      '**/*_1.*',  // sometimes sync logic bug will resulted in file ends with _1, which will cause lots of trouble\n      '**/subwiki/**',\n      '**/.DS_Store',\n      '**/.git'\n    ],\n    atomic: true,\n    useFsEvents: false   // fsevents is not bundled with 3rds.js\n    //usePolling: true,  // CHOKIDAR_USEPOLLING=1\n  });\n  \n  watcher.on('all', listener);\n}\n\nFileSystemMonitor();\n",
            "creator": "LinOnetwo",
            "type": "application/javascript",
            "module-type": "startup"
        },
        "$:/config/SyncPollingInterval": {
            "title": "$:/config/SyncPollingInterval",
            "type": "text/vnd.tiddlywiki",
            "text": "32140800000"
        },
        "$:/plugins/linonetwo/watch-fs/deep-equal.js": {
            "title": "$:/plugins/linonetwo/watch-fs/deep-equal.js",
            "text": "module.exports = function deepEqual(x, y) {\n  if (x === y) {\n    return true;\n  }\n  if (titleListEqual(x, y)) {\n    // handle title list https://tiddlywiki.com/#Title%20List\n    /* tiddler {\n      \"title\": \"$:/StoryList\",\n      \"list\": \"Index\"\n    }\n    tiddlerInWiki {\n      \"title\": \"$:/StoryList\",\n      \"list\": [\n        \"Index\"\n      ]\n    } */\n    return true;\n  }\n  if (timeStampEqual(x, y)) {\n    // handles time stamp format\n    /* tiddler {\n      \"title\": \"$:/StoryList\",\n      \"created\": \"20200806161101351\",\n      \"list\": \"Index\",\n      \"modified\": \"20200806161101351\",\n      \"type\": \"text/vnd.tiddlywiki\"\n    }\n    tiddlerInWiki {\n      \"title\": \"$:/StoryList\",\n      \"created\": \"2020-08-06T16:11:01.351Z\",\n      \"list\": [\n        \"Index\"\n      ],\n      \"modified\": \"2020-08-06T16:11:01.351Z\",\n      \"type\": \"text/vnd.tiddlywiki\"\n    } */\n    return true;\n  }\n  if (typeof x === 'object' && x !== null && typeof y === 'object' && y !== null) {\n    deleteRuntimeFieldsFromTiddler(x);\n    deleteRuntimeFieldsFromTiddler(y);\n    if (Object.keys(x).length !== Object.keys(y).length) return false;\n\n    for (const property in x) {\n      if (!deepEqual(x[property], y[property])) return false;\n    }\n\n    return true;\n  }\n  return false;\n};\n\nfunction titleListEqual(x, y) {\n  // y is like \"GettingStarted [[Discover TiddlyWiki]] Upgrading\", and x is an array\n  if (typeof x === 'string' && Array.isArray(y)) {\n    // $tw.utils.parseStringArray is heavy, so we use $tw.utils.stringifyList instead\n    return $tw.utils.stringifyList(y) === x;\n  }\n  if (typeof y === 'string' && Array.isArray(x)) {\n    return $tw.utils.stringifyList(x) === y;\n  }\n  return false;\n}\n\nfunction timeStampEqual(x, y) {\n  // strangely, `created` and `modified` field is not instanceof Date, so have to use x === 'object' to check it\n  if (typeof y === 'object' && y.toString && Object.keys(y).length === 0 && typeof x === 'string') {\n    return JSON.stringify(y).replace(/[\".:TZ-]/g, '') === x;\n  }\n  if (typeof x === 'object' && x.toString && Object.keys(x).length === 0 && typeof y === 'string') {\n    return JSON.stringify(x).replace(/[\".:TZ-]/g, '') === y;\n  }\n  if (typeof x === 'string' && typeof y === 'string') {\n    return x.replace(/[.:TZ-]/g, '') === y || y.replace(/[.:TZ-]/g, '') === x;\n  }\n  return false;\n}\n\nconst fieldsToDelete = ['bag', 'revision'];\n/**\n * Delete things like \"bag\" and \"revision\" that doesn't save to file\n * @param {tiddler.fields} tiddlerFields\n */\nfunction deleteRuntimeFieldsFromTiddler(tiddlerFields) {\n  for (const fieldName of fieldsToDelete) {\n    if (fieldName in tiddlerFields) {\n      delete tiddlerFields[fieldName];\n    }\n  }\n}\n",
            "creator": "LinOnetwo",
            "type": "application/javascript",
            "module-type": "startup"
        },
        "$:/plugins/linonetwo/watch-fs/get-can-sync.js": {
            "title": "$:/plugins/linonetwo/watch-fs/get-can-sync.js",
            "text": "/*\\\ntitle: $:/plugins/linonetwo/watch-fs/get-can-sync.js\ntype: application/javascript\nmodule-type: route\nGET /watch-fs-can-sync\n\\*/\n(function () {\n  exports.method = 'GET';\n\n  // route should start with something https://github.com/Jermolene/TiddlyWiki5/issues/4807\n  exports.path = /^\\/linonetwo\\/watch-fs-can-sync$/;\n\n  exports.handler = function handler(request, response, state) {\n    response.writeHead(200, { 'Content-Type': 'application/json' });\n    const { canSync } = state.wiki.watchFs;\n    response.end(JSON.stringify(canSync), 'utf8');\n  };\n})();\n",
            "type": "application/javascript",
            "module-type": "route",
            "creator": "LinOnetwo"
        },
        "$:/plugins/linonetwo/watch-fs/has-native-recursive.js": {
            "title": "$:/plugins/linonetwo/watch-fs/has-native-recursive.js",
            "text": "/**\n  title: $:/plugins/linonetwo/watch-fs/has-native-recursive.js\n  type: application/javascript\n  module-type: startup\n * https://github.com/yuanchuan/node-watch\n * @version 0.6.4\n */\nfunction hasNativeRecursiveIIFE() {\n  if (typeof $tw === 'undefined' || !$tw?.node) return;\n  exports.name = 'watch-fs_has-native-recursive';\n  exports.after = ['load-modules', 'watch-fs_is'];\n  exports.platforms = ['node'];\n  exports.synchronous = true;\n\n  const fs = require('fs');\n  const os = require('os');\n  const path = require('path');\n  const is = require('./is');\n\n  let IS_SUPPORT;\n  const TEMP_DIR = (os.tmpdir && os.tmpdir()) || process.env.TMPDIR || process.env.TEMP || process.cwd();\n\n  function TemporaryStack() {\n    this.stack = [];\n  }\n\n  TemporaryStack.prototype = {\n    create(type, base) {\n      const name = path.join(\n        base,\n        `node-watch-${Math.random()\n          .toString(16)\n          .slice(2)}`,\n      );\n      this.stack.push({ name, type });\n      return name;\n    },\n    write(/* file */) {\n      for (const argument of arguments) {\n        fs.writeFileSync(argument, ' ');\n      }\n    },\n    mkdir(/* dirs */) {\n      for (const argument of arguments) {\n        fs.mkdirSync(argument);\n      }\n    },\n    cleanup(fn) {\n      try {\n        let temporary;\n        while ((temporary = this.stack.pop())) {\n          const { type } = temporary;\n          const { name } = temporary;\n          if (type === 'file' && is.file(name)) {\n            fs.unlinkSync(name);\n          } else if (type === 'dir' && is.directory(name)) {\n            fs.rmdirSync(name);\n          }\n        }\n      } finally {\n        if (is.func(fn)) fn();\n      }\n    },\n  };\n\n  let pending = false;\n\n  module.exports = function hasNativeRecursive(fn) {\n    if (!is.func(fn)) {\n      return false;\n    }\n    if (IS_SUPPORT !== undefined) {\n      return fn(IS_SUPPORT);\n    }\n\n    if (!pending) {\n      pending = true;\n    }\n    // check again later\n    else {\n      return setTimeout(function() {\n        hasNativeRecursive(fn);\n      }, 300);\n    }\n\n    const stack = new TemporaryStack();\n    const parent = stack.create('dir', TEMP_DIR);\n    const child = stack.create('dir', parent);\n    const file = stack.create('file', child);\n\n    stack.mkdir(parent, child);\n\n    const options = { recursive: true };\n    let watcher;\n\n    try {\n      watcher = fs.watch(parent, options);\n    } catch (error) {\n      if (error.code == 'ERR_FEATURE_UNAVAILABLE_ON_PLATFORM') {\n        return fn((IS_SUPPORT = false));\n      }\n      throw error;\n    }\n\n    if (!watcher) {\n      return false;\n    }\n\n    const timer = setTimeout(function() {\n      watcher.close();\n      stack.cleanup(function() {\n        fn((IS_SUPPORT = false));\n      });\n    }, 200);\n\n    watcher.on('change', function(event, name) {\n      if (path.basename(file) === path.basename(name)) {\n        watcher.close();\n        clearTimeout(timer);\n        stack.cleanup(function() {\n          fn((IS_SUPPORT = true));\n        });\n      }\n    });\n    stack.write(file);\n  };\n}\nhasNativeRecursiveIIFE();\n",
            "creator": "LinOnetwo",
            "type": "application/javascript",
            "module-type": "startup"
        },
        "$:/plugins/linonetwo/watch-fs/is.js": {
            "title": "$:/plugins/linonetwo/watch-fs/is.js",
            "text": "/**\n  title: $:/plugins/linonetwo/watch-fs/is.js\n  type: application/javascript\n  module-type: startup\n * https://github.com/yuanchuan/node-watch\n * @version 0.6.4\n */\n\nfunction isIIFE() {\n  if (typeof $tw === 'undefined' || !$tw?.node) return;\n  exports.name = 'watch-fs_is';\n  exports.after = ['load-modules'];\n  exports.platforms = ['node'];\n  exports.synchronous = true;\n\n  const fs = require('fs');\n  const path = require('path');\n  const os = require('os');\n\n  function matchObject(item, string) {\n    return Object.prototype.toString.call(item) === `[object ${string}]`;\n  }\n\n  function checkStat(name, fn) {\n    try {\n      return fn(name);\n    } catch (error) {\n      if (/^(ENOENT|EPERM|EACCES)$/.test(error.code)) {\n        if (error.code !== 'ENOENT') {\n          console.warn('Warning: Cannot access %s', name);\n        }\n        return false;\n      }\n      throw error;\n    }\n  }\n\n  const is = {\n    nil(item) {\n      return item == undefined;\n    },\n    array(item) {\n      return Array.isArray(item);\n    },\n    emptyObject(item) {\n      for (const key in item) {\n        return false;\n      }\n      return true;\n    },\n    buffer(item) {\n      return Buffer.isBuffer(item);\n    },\n    regExp(item) {\n      return matchObject(item, 'RegExp');\n    },\n    string(item) {\n      return matchObject(item, 'String');\n    },\n    func(item) {\n      return typeof item === 'function';\n    },\n    number(item) {\n      return matchObject(item, 'Number');\n    },\n    exists(name) {\n      return fs.existsSync(name);\n    },\n    file(name) {\n      return checkStat(name, function(n) {\n        return fs.statSync(n).isFile();\n      });\n    },\n    samePath(a, b) {\n      return path.resolve(a) === path.resolve(b);\n    },\n    directory(name) {\n      return checkStat(name, function(n) {\n        return fs.statSync(n).isDirectory();\n      });\n    },\n    symbolicLink(name) {\n      return checkStat(name, function(n) {\n        return fs.lstatSync(n).isSymbolicLink();\n      });\n    },\n    windows() {\n      return os.platform() === 'win32';\n    },\n  };\n\n  module.exports = is;\n}\nisIIFE();\n",
            "creator": "LinOnetwo",
            "type": "application/javascript",
            "module-type": "startup"
        },
        "$:/plugins/linonetwo/watch-fs/readme": {
            "title": "$:/plugins/linonetwo/watch-fs/readme",
            "creator": "LinOnetwo",
            "type": "text/vnd.tiddlywiki",
            "text": "!! About\n\nThis plugin enables TiddlyWiki to watch the change in your disk, and if you edit one of your tiddler using editor likes VSCode and save it on the disk, the change will immediately reflected in the browser.\n\nSee [[https://github.com/Jermolene/TiddlyWiki5/issues/3060]] for related discussions.\n\n!! [[FileSystemMonitor.js|$:/plugins/linonetwo/watch-fs/FileSystemMonitor.js]]\n\nThis module watches the file system in the tiddlers folder and any changes to\nthe files in the folder that don't come from the browser are reported to the\nbrowser. So if you make a new .tid file in the tiddlers folder it will appear\nin the wiki in the browser without needing to restart the server. You can also\ndelete files to remove the tiddlers from the browser.\n\n!! Usage\n\nThis plugin will cause trouble if you build wiki with it enabled,\nso you have to remove it from your `tiddlywiki.info`, and add it to your wiki start arguments:\n\n```shell\ntiddlywiki +plugins/tiddlywiki/filesystem +plugins/tiddlywiki/tiddlyweb +plugins/linonetwo/watch-fs <path-to-wiki-folder> --listen\n```\n\n(why `+plugins/tiddlywiki/filesystem +plugins/tiddlywiki/tiddlyweb` here? See [[https://github.com/Jermolene/TiddlyWiki5/issues/4484#issuecomment-613200370]] for details)\n\n!!! Liminitation\n\n# can't handle rename in the disk, you can only rename from within the wiki (no such API to tell tw I've renamed a file)\n# I haven't tested this with [[$:/config/FileSystemPaths]] and [[Fix file info PR|https://github.com/Jermolene/TiddlyWiki5/pull/4630]] , but I use this feature every day, so I will definitely support it.\n# Can't handle if git change the tiddler while you are open its Draft tiddler (might be fixed by [[Deleting a draft tiddler should not also delete the original tiddler|https://github.com/Jermolene/TiddlyWiki5/issues/4792]] )\n\n!! Implementation Details\n\n!!! How to decide whether a change is comes from the browser?\n\nWe will compare disk file and wiki file, if there is any discrepancy,\nthen we know the change is not made from the wiki, it is made by git or VSCode, in this case we read data from the disc,\nand add data to the tiddlywiki.\n\n!!! How to sync changes to the browser?\n\nwe can't trigger sync from the server, so we have to set a smaller sync interval in the client side.\n\nSo this plugin ship with a large [[$:/config/SyncPollingInterval]] to disable the build-in sync,\nand we add a new route `/linonetwo/watch-fs-can-sync` to the simple server, it will return `true` or `false`,\nand browser will poll this route, to see if it needs to trigger a `$tw.syncer.syncFromServer()`.\n"
        },
        "$:/plugins/linonetwo/watch-fs/trigger-sync.html": {
            "title": "$:/plugins/linonetwo/watch-fs/trigger-sync.html",
            "text": "<script type=\"application/javascript\">\n  const checkCanSyncInterval = 1000; // ms\n  // check if we are using IME, which will be interrupt by the sync\n  let isTypingUsingIME = false;\n  document.addEventListener('compositionstart', () => {\n    isTypingUsingIME = true;\n  });\n  document.addEventListener('compositionend', () => {\n    isTypingUsingIME = false;\n  });\n  // after we sync, set this to false\n  let deSync = false;\n  setInterval(async function checkCanSync() {\n    // don't trigger sync if user is typing using IME\n    if (isTypingUsingIME) return;\n    // debounced sync indicator, will be true if there is no change in the disc for several seconds\n    const canSync = (await fetch('/linonetwo/watch-fs-can-sync').then(response => response.text())) === 'true';\n    if (!deSync && !canSync) {\n      // we have previously synced, and server have changes that is not debounced yet\n      deSync = true;\n    }\n    if (canSync && deSync) {\n      $tw.syncer.syncFromServer();\n      deSync = false;\n    }\n  }, checkCanSyncInterval);\n</script>\n",
            "type": "text/html",
            "creator": "LinOnetwo",
            "tags": "$:/tags/RawMarkup"
        },
        "$:/plugins/linonetwo/watch-fs/utils.js": {
            "title": "$:/plugins/linonetwo/watch-fs/utils.js",
            "text": "/**\n * Given a tiddler title and an array of existing filenames, generate a new legal filename for the title,\n * case insensitively avoiding the array of existing filenames\n *\n * Modified from TW-Bob's FileSystem/MultiWikiAdaptor.js\n *\n * @param {string} title\n */\nfunction generateTiddlerBaseFilepath(title) {\n  let baseFilename;\n  // Check whether the user has configured a tiddler -> pathname mapping\n  const pathNameFilters = $tw.wiki.getTiddlerText('$:/config/FileSystemPaths');\n  if (pathNameFilters) {\n    const source = $tw.wiki.makeTiddlerIterator([title]);\n    baseFilename = this.findFirstFilter(pathNameFilters.split('\\n'), source);\n    if (baseFilename) {\n      // Interpret \"/\" and \"\\\" as path separator\n      baseFilename = baseFilename.replace(/\\/|\\\\/g, path.sep);\n    }\n  }\n  if (!baseFilename) {\n    // No mappings provided, or failed to match this tiddler so we use title as filename\n    baseFilename = title.replace(/\\/|\\\\/g, '_');\n  }\n  // Remove any of the characters that are illegal in Windows filenames\n  baseFilename = $tw.utils.transliterate(baseFilename.replace(/<|>|\\:|\\\"|\\||\\?|\\*|\\^/g, '_'));\n  // Truncate the filename if it is too long\n  if (baseFilename.length > 200) {\n    baseFilename = baseFilename.substr(0, 200);\n  }\n  return baseFilename;\n}\n\nfunction findFirstFilter(filters, source) {\n  for (let i = 0; i < filters.length; i++) {\n    const result = $tw.wiki.filterTiddlers(filters[i], null, source);\n    if (result.length > 0) {\n      return result[0];\n    }\n  }\n  return null;\n}\n\nmodule.exports = {\n  generateTiddlerBaseFilepath,\n};\n",
            "creator": "LinOnetwo",
            "type": "application/javascript",
            "module-type": "startup"
        },
        "$:/plugins/linonetwo/watch-fs/watch.js": {
            "title": "$:/plugins/linonetwo/watch-fs/watch.js",
            "text": "/**\n  title: $:/plugins/linonetwo/watch-fs/watch.js\n  type: application/javascript\n  module-type: startup\n * https://github.com/yuanchuan/node-watch\n * @version 0.6.4\n */\n\nfunction watchIIFE() {\n  if (typeof $tw === 'undefined' || !$tw?.node) return;\n  exports.name = 'watch-fs_watch';\n  exports.after = ['load-modules', 'watch-fs_is', 'watch-fs_has-native-recursive'];\n  exports.platforms = ['node'];\n  exports.synchronous = true;\n\n  const fs = require('fs');\n  const path = require('path');\n  const util = require('util');\n  const events = require('events');\n\n  const hasNativeRecursive = require('./has-native-recursive');\n  const is = require('./is');\n\n  const EVENT_UPDATE = 'update';\n  const EVENT_REMOVE = 'remove';\n\n  function hasDup(array) {\n    return array.some(function(v, i, self) {\n      return self.indexOf(v) !== i;\n    });\n  }\n\n  function unique(array) {\n    return array.filter(function(v, i, self) {\n      return self.indexOf(v) === i;\n    });\n  }\n\n  function assertEncoding(encoding) {\n    if (encoding && encoding !== 'buffer' && !Buffer.isEncoding(encoding)) {\n      throw new Error(`Unknown encoding: ${encoding}`);\n    }\n  }\n\n  function guard(fn) {\n    return function(argument, action) {\n      if (is.func(fn)) {\n        if (fn(argument)) action();\n      } else if (is.regExp(fn)) {\n        if (fn.test(argument)) action();\n      } else {\n        action();\n      }\n    };\n  }\n\n  function composeMessage(names) {\n    return names.map(function(n) {\n      return is.exists(n) ? [EVENT_UPDATE, n] : [EVENT_REMOVE, n];\n    });\n  }\n\n  function getMessages(cache) {\n    let filtered = unique(cache);\n\n    // Saving file from an editor? If so, assuming the\n    // non-existed files in the cache are temporary files\n    // generated by an editor and thus be filtered.\n    const reg = /~$|^\\.#|^##$/g;\n    const hasSpecialChar = cache.some(function(c) {\n      return reg.test(c);\n    });\n\n    if (hasSpecialChar) {\n      const dup = hasDup(\n        cache.map(function(c) {\n          return c.replace(reg, '');\n        }),\n      );\n      if (dup) {\n        filtered = filtered.filter(function(m) {\n          return is.exists(m);\n        });\n      }\n    }\n\n    // Prevent redundant event for its parent when creating file/directory.\n    // The operation is kinda expensive so only be triggered under Windows.\n    // https://github.com/yuanchuan/node-watch/issues/79\n    if (is.windows()) {\n      const parents = filtered.map(function(n) {\n        return path.parse(n).dir;\n      });\n      filtered = filtered.filter(function(n) {\n        // Skip on removal\n        if (!is.exists(n)) {\n          return true;\n        }\n        // Ignore the parent directory\n        return !parents.some(function(m) {\n          return is.samePath(n, m);\n        });\n      });\n    }\n\n    return composeMessage(filtered);\n  }\n\n  function debounce(info, fn) {\n    let timer;\n    let cache = [];\n    const { encoding } = info.options;\n    let { delay } = info.options;\n    if (!is.number(delay)) {\n      delay = 200;\n    }\n    function handle() {\n      getMessages(cache).forEach(function(message) {\n        message[1] = Buffer.from(message[1]);\n        if (encoding !== 'buffer') {\n          message[1] = message[1].toString(encoding);\n        }\n        fn.apply(null, message);\n      });\n      timer = null;\n      cache = [];\n    }\n    return function(rawEvent, name) {\n      cache.push(name);\n      if (!timer) {\n        timer = setTimeout(handle, delay);\n      }\n    };\n  }\n\n  function createDupsFilter() {\n    let memo = {};\n    return function(fn) {\n      return function(event, name) {\n        memo[event + name] = [event, name];\n        setTimeout(function() {\n          Object.keys(memo).forEach(function(n) {\n            fn.apply(null, memo[n]);\n          });\n          memo = {};\n        });\n      };\n    };\n  }\n\n  function getSubDirectories(dir, fn, done = function() {}) {\n    if (is.directory(dir)) {\n      fs.readdir(dir, function(error, all) {\n        if (error) {\n          // don't throw permission errors.\n          if (/^(EPERM|EACCES)$/.test(error.code)) {\n            console.warn('Warning: Cannot access %s.', dir);\n          } else {\n            throw error;\n          }\n        } else {\n          all.forEach(function(f) {\n            const sdir = path.join(dir, f);\n            if (is.directory(sdir)) fn(sdir);\n          });\n          done();\n        }\n      });\n    } else {\n      done();\n    }\n  }\n\n  function semaphore(final) {\n    let counter = 0;\n    return function start() {\n      counter++;\n      return function stop() {\n        counter--;\n        if (counter === 0) final();\n      };\n    };\n  }\n\n  function nullCounter() {\n    return function nullStop() {};\n  }\n\n  const deprecationWarning = util.deprecate(function() {},\n  '(node-watch) First param in callback function\\\n  is replaced with event name since 0.5.0, use\\\n  `(evt, filename) => {}` if you want to get the filename');\n\n  function Watcher() {\n    events.EventEmitter.call(this);\n    this.watchers = {};\n    this._isReady = false;\n    this._isClosed = false;\n  }\n\n  util.inherits(Watcher, events.EventEmitter);\n\n  Watcher.prototype.expose = function() {\n    const self = this;\n    const methods = ['on', 'emit', 'close', 'isClosed', 'listeners', 'once', 'setMaxListeners', 'getMaxListeners'];\n    return methods.reduce(function(expose, name) {\n      expose[name] = function() {\n        return self[name].apply(self, arguments);\n      };\n      return expose;\n    }, {});\n  };\n\n  Watcher.prototype.isClosed = function() {\n    return this._isClosed;\n  };\n\n  Watcher.prototype.close = function(fullPath) {\n    const self = this;\n    if (fullPath) {\n      const watcher = this.watchers[fullPath];\n      if (watcher && watcher.close) {\n        watcher.close();\n        delete self.watchers[fullPath];\n      }\n      getSubDirectories(fullPath, function(fpath) {\n        self.close(fpath);\n      });\n    } else {\n      Object.keys(self.watchers).forEach(function(fpath) {\n        const watcher = self.watchers[fpath];\n        if (watcher && watcher.close) {\n          watcher.close();\n        }\n      });\n      this.watchers = {};\n    }\n    // Do not close the Watcher unless all child watchers are closed.\n    // https://github.com/yuanchuan/node-watch/issues/75\n    if (is.emptyObject(self.watchers)) {\n      this._isClosed = true;\n      process.nextTick(emitClose, this);\n    }\n  };\n\n  function emitReady(self) {\n    if (!self._isReady) {\n      self._isReady = true;\n      // do not call emit for 'ready' until after watch() has returned,\n      // so that consumer can call on().\n      process.nextTick(function() {\n        self.emit('ready');\n      });\n    }\n  }\n\n  function emitClose(self) {\n    self.emit('close');\n  }\n\n  Watcher.prototype.add = function(watcher, info) {\n    const self = this;\n    info = info || { fpath: '' };\n    const watcherPath = path.resolve(info.fpath);\n    this.watchers[watcherPath] = watcher;\n\n    // Internal callback for handling fs.FSWatcher 'change' events\n    const internalOnChange = function(rawEvent, rawName) {\n      if (self.isClosed()) {\n        return;\n      }\n\n      // normalise lack of name and convert to full path\n      let name = rawName;\n      if (is.nil(name)) {\n        name = '';\n      }\n      name = path.join(info.fpath, name);\n\n      if (info.options.recursive) {\n        hasNativeRecursive(function(has) {\n          if (!has) {\n            const fullPath = path.resolve(name);\n            // remove watcher on removal\n            if (!is.exists(name)) {\n              self.close(fullPath);\n            }\n            // watch new created directory\n            else if (is.directory(name) && !self.watchers[fullPath]) {\n              self.watchDirectory(name, info.options);\n            }\n          }\n        });\n      }\n\n      handlePublicEvents(rawEvent, name);\n    };\n\n    // Debounced based on the 'delay' option\n    var handlePublicEvents = debounce(info, function(event, name) {\n      // watch single file\n      if (info.compareName) {\n        if (info.compareName(name)) {\n          self.emit('change', event, name);\n        }\n      }\n      // watch directory\n      else {\n        const filterGuard = guard(info.options.filter);\n        filterGuard(name, function() {\n          if (self.flag) self.flag = '';\n          else self.emit('change', event, name);\n        });\n      }\n    });\n\n    watcher.on('error', function(error) {\n      if (self.isClosed()) {\n        return;\n      }\n      if (is.windows() && error.code === 'EPERM') {\n        watcher.emit('change', EVENT_REMOVE, info.fpath && '');\n        self.flag = 'windows-error';\n        self.close(watcherPath);\n      } else {\n        self.emit('error', error);\n      }\n    });\n\n    watcher.on('change', internalOnChange);\n  };\n\n  Watcher.prototype.watchFile = function(file, options, fn) {\n    const parent = path.join(file, '../');\n    const options_ = {\n      ...options, // no filter for single file\n      filter: null,\n      encoding: 'utf8',\n    };\n\n    // no need to watch recursively\n    delete options_.recursive;\n\n    const watcher = fs.watch(parent, options_);\n    this.add(watcher, {\n      type: 'file',\n      fpath: parent,\n      options: { ...options_, encoding: options.encoding },\n      compareName(n) {\n        return is.samePath(n, file);\n      },\n    });\n\n    if (is.func(fn)) {\n      if (fn.length === 1) deprecationWarning();\n      this.on('change', fn);\n    }\n  };\n\n  Watcher.prototype.watchDirectory = function(dir, options, fn, counter = nullCounter) {\n    const self = this;\n    const done = counter();\n    hasNativeRecursive(function(has) {\n      // always specify recursive\n      options.recursive = !!options.recursive;\n      // using utf8 internally\n      const options_ = { ...options, encoding: 'utf8' };\n      if (!has) {\n        delete options_.recursive;\n      }\n\n      const watcher = fs.watch(dir, options_);\n\n      self.add(watcher, {\n        type: 'dir',\n        fpath: dir,\n        options,\n      });\n\n      if (is.func(fn)) {\n        if (fn.length === 1) deprecationWarning();\n        self.on('change', fn);\n      }\n\n      if (options.recursive && !has) {\n        getSubDirectories(\n          dir,\n          function(d) {\n            self.watchDirectory(d, options, null, counter);\n          },\n          counter(),\n        );\n      }\n\n      done();\n    });\n  };\n\n  function composeWatcher(watchers) {\n    const watcher = new Watcher();\n    const filterDups = createDupsFilter();\n    let counter = watchers.length;\n    watchers.forEach(function(w) {\n      w.on(\n        'change',\n        filterDups(function(event, name) {\n          watcher.emit('change', event, name);\n        }),\n      );\n      w.on('error', function(error) {\n        watcher.emit('error', error);\n      });\n      w.on('ready', function() {\n        if (!--counter) {\n          emitReady(watcher);\n        }\n      });\n    });\n\n    watcher.close = function() {\n      watchers.forEach(function(w) {\n        w.close();\n      });\n      process.nextTick(emitClose, watcher);\n    };\n    return watcher.expose();\n  }\n\n  function watch(fpath, options, fn) {\n    const watcher = new Watcher();\n\n    if (is.buffer(fpath)) {\n      fpath = fpath.toString();\n    }\n\n    if (is.array(fpath)) {\n      if (fpath.length === 1) {\n        return watch(fpath[0], options, fn);\n      }\n      const filterDups = createDupsFilter();\n      return composeWatcher(\n        unique(fpath).map(function(f) {\n          const w = watch(f, options);\n          if (fn) w.on('change', filterDups(fn));\n          return w;\n        }),\n      );\n    }\n\n    if (!is.exists(fpath)) {\n      watcher.emit('error', new Error(`${fpath} does not exist.`));\n    }\n\n    if (is.string(options)) {\n      options = {\n        encoding: options,\n      };\n    }\n\n    if (is.func(options)) {\n      fn = options;\n      options = {};\n    }\n\n    if (arguments.length < 2) {\n      options = {};\n    }\n\n    if (options.encoding) {\n      assertEncoding(options.encoding);\n    } else {\n      options.encoding = 'utf8';\n    }\n\n    if (is.file(fpath)) {\n      watcher.watchFile(fpath, options, fn);\n      emitReady(watcher);\n    } else if (is.directory(fpath)) {\n      const counter = semaphore(function() {\n        emitReady(watcher);\n      });\n      watcher.watchDirectory(fpath, options, fn, counter);\n    }\n\n    return watcher.expose();\n  }\n\n  module.exports = watch;\n  module.exports.default = watch;\n}\nwatchIIFE();\n",
            "creator": "LinOnetwo",
            "type": "application/javascript",
            "module-type": "startup"
        }
    }
}